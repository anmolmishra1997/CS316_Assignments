Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> block_list
Rule 2     block_list -> basic_block block_list
Rule 3     block_list -> basic_block
Rule 4     basic_block -> declaration
Rule 5     basic_block -> function
Rule 6     basic_block -> function_prototype
Rule 7     function -> TYPE var seen_FM LPAREN parameter_list RPAREN function_body
Rule 8     function -> VOID NAME seen_FM LPAREN parameter_list RPAREN function_body
Rule 9     function -> TYPE var seen_FM LPAREN RPAREN function_body
Rule 10    function -> VOID NAME seen_FM LPAREN RPAREN function_body
Rule 11    function -> VOID MAIN seen_FM LPAREN RPAREN function_body
Rule 12    seen_FM -> <empty>
Rule 13    function_prototype -> TYPE var seen_FM LPAREN parameter_list RPAREN SEMICOLON
Rule 14    function_prototype -> TYPE var seen_FM LPAREN RPAREN SEMICOLON
Rule 15    function_prototype -> VOID NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON
Rule 16    function_prototype -> VOID NAME seen_FM LPAREN RPAREN SEMICOLON
Rule 17    parameter_list -> TYPE var COMMA parameter_list
Rule 18    parameter_list -> TYPE var
Rule 19    TYPE -> INT
Rule 20    TYPE -> FLOAT
Rule 21    function_body -> LCURLY stmt_list return_stmt RCURLY
Rule 22    function_body -> LCURLY return_stmt RCURLY
Rule 23    function_body -> body
Rule 24    return_stmt -> RETURN SEMICOLON
Rule 25    return_stmt -> RETURN R2 SEMICOLON
Rule 26    body -> LCURLY stmt_list RCURLY
Rule 27    body -> LCURLY RCURLY
Rule 28    stmt_list -> stmt stmt_list
Rule 29    stmt_list -> stmt
Rule 30    stmt -> matched_stmt
Rule 31    stmt -> unmatched_stmt
Rule 32    matched_stmt -> assign
Rule 33    matched_stmt -> declaration
Rule 34    matched_stmt -> matched_decision
Rule 35    matched_stmt -> matched_loop
Rule 36    matched_stmt -> function_call SEMICOLON
Rule 37    unmatched_stmt -> unmatched_decision
Rule 38    unmatched_stmt -> unmatched_loop
Rule 39    assign -> L1 EQUALS R1 SEMICOLON
Rule 40    assign -> L2 EQUALS R2 SEMICOLON
Rule 41    L1 -> NAME
Rule 42    R1 -> R1 PLUS ALLNUM
Rule 43    R1 -> R1 MINUS ALLNUM
Rule 44    R1 -> R1 STAR ALLNUM
Rule 45    R1 -> R1 DIVIDE ALLNUM
Rule 46    R1 -> ALLNUM PLUS R1
Rule 47    R1 -> ALLNUM MINUS R1
Rule 48    R1 -> ALLNUM STAR R1
Rule 49    R1 -> ALLNUM DIVIDE R1
Rule 50    R1 -> R1 PLUS R1
Rule 51    R1 -> R1 MINUS R1
Rule 52    R1 -> R1 STAR R1
Rule 53    R1 -> R1 DIVIDE R1
Rule 54    R1 -> LPAREN R1 RPAREN
Rule 55    R1 -> MINUS R1
Rule 56    R1 -> PName
Rule 57    R1 -> function_call
Rule 58    R1 -> NAME
Rule 59    ALLNUM -> NUMBER
Rule 60    ALLNUM -> MINUS ALLNUM
Rule 61    L2 -> STAR L2
Rule 62    L2 -> STAR NAME
Rule 63    R2 -> R2 PLUS R2
Rule 64    R2 -> R2 MINUS R2
Rule 65    R2 -> R2 STAR R2
Rule 66    R2 -> R2 DIVIDE R2
Rule 67    R2 -> LPAREN R2 RPAREN
Rule 68    R2 -> MINUS R2
Rule 69    R2 -> PName
Rule 70    R2 -> function_call
Rule 71    R2 -> NAME
Rule 72    R2 -> NUMBER
Rule 73    PName -> STAR PName
Rule 74    PName -> STAR NAME
Rule 75    PName -> AMPERSAND NAME
Rule 76    function_call -> NAME LPAREN arg_list RPAREN
Rule 77    function_call -> NAME LPAREN RPAREN
Rule 78    arg_list -> R2 COMMA arg_list
Rule 79    arg_list -> R2
Rule 80    declaration -> TYPE varlist SEMICOLON
Rule 81    varlist -> var COMMA varlist
Rule 82    varlist -> var
Rule 83    var -> STAR var
Rule 84    var -> NAME
Rule 85    matched_loop -> WHILE LPAREN condition RPAREN matched_stmt
Rule 86    matched_loop -> WHILE LPAREN condition RPAREN body
Rule 87    matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON
Rule 88    unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt
Rule 89    condition -> condition AND condition
Rule 90    condition -> condition OR condition
Rule 91    condition -> LPAREN condition RPAREN
Rule 92    condition -> NOT condition
Rule 93    condition -> R2 GT R2
Rule 94    condition -> R2 LT R2
Rule 95    condition -> R2 GE R2
Rule 96    condition -> R2 LE R2
Rule 97    condition -> R2 EQ R2
Rule 98    condition -> R2 NE R2
Rule 99    matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
Rule 100   matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body
Rule 101   matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt
Rule 102   matched_decision -> IF LPAREN condition RPAREN body ELSE body
Rule 103   matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
Rule 104   matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON
Rule 105   matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
Rule 106   matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body
Rule 107   matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
Rule 108   unmatched_decision -> IF LPAREN condition RPAREN stmt
Rule 109   unmatched_decision -> IF LPAREN condition RPAREN body
Rule 110   unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON
Rule 111   unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
Rule 112   unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt
Rule 113   unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt

Terminals, with rules where they appear

AMPERSAND            : 75
AND                  : 89
COMMA                : 17 78 81
DIVIDE               : 45 49 53 66
ELSE                 : 99 100 101 102 103 104 105 106 107 111 112 113
EQ                   : 97
EQUALS               : 39 40
FLOAT                : 20
GE                   : 95
GT                   : 93
IF                   : 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113
INT                  : 19
LCURLY               : 21 22 26 27
LE                   : 96
LPAREN               : 7 8 9 10 11 13 14 15 16 54 67 76 77 85 86 87 88 91 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113
LT                   : 94
MAIN                 : 11
MINUS                : 43 47 51 55 60 64 68
NAME                 : 8 10 15 16 41 58 62 71 74 75 76 77 84
NE                   : 98
NOT                  : 92
NUMBER               : 59 72
OR                   : 90
PLUS                 : 42 46 50 63
RCURLY               : 21 22 26 27
RETURN               : 24 25
RPAREN               : 7 8 9 10 11 13 14 15 16 54 67 76 77 85 86 87 88 91 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113
SEMICOLON            : 13 14 15 16 24 25 36 39 40 80 87 103 104 105 106 107 107 110 113
STAR                 : 44 48 52 61 62 65 73 74 83
VOID                 : 8 10 11 15 16
WHILE                : 85 86 87 88
error                : 

Nonterminals, with rules where they appear

ALLNUM               : 42 43 44 45 46 47 48 49 60
L1                   : 39
L2                   : 40 61
PName                : 56 69 73
R1                   : 39 42 43 44 45 46 47 48 49 50 50 51 51 52 52 53 53 54 55
R2                   : 25 40 63 63 64 64 65 65 66 66 67 68 78 79 93 93 94 94 95 95 96 96 97 97 98 98
TYPE                 : 7 9 13 14 17 18 80
arg_list             : 76 78
assign               : 32
basic_block          : 2 3
block_list           : 1 2
body                 : 23 86 100 101 102 102 104 106 109 112
condition            : 85 86 87 88 89 89 90 90 91 92 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113
declaration          : 4 33
function             : 5
function_body        : 7 8 9 10 11
function_call        : 36 57 70
function_prototype   : 6
matched_decision     : 34
matched_loop         : 35
matched_stmt         : 30 85 99 99 100 101 103 105 111
parameter_list       : 7 8 13 15 17
program              : 0
return_stmt          : 21 22
seen_FM              : 7 8 9 10 11 13 14 15 16
stmt                 : 28 29 108
stmt_list            : 21 26 28
unmatched_decision   : 37
unmatched_loop       : 38
unmatched_stmt       : 31 88 111 112 113
var                  : 7 9 13 14 17 18 81 82 83
varlist              : 80 81

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block_list
    (2) block_list -> . basic_block block_list
    (3) block_list -> . basic_block
    (4) basic_block -> . declaration
    (5) basic_block -> . function
    (6) basic_block -> . function_prototype
    (80) declaration -> . TYPE varlist SEMICOLON
    (7) function -> . TYPE var seen_FM LPAREN parameter_list RPAREN function_body
    (8) function -> . VOID NAME seen_FM LPAREN parameter_list RPAREN function_body
    (9) function -> . TYPE var seen_FM LPAREN RPAREN function_body
    (10) function -> . VOID NAME seen_FM LPAREN RPAREN function_body
    (11) function -> . VOID MAIN seen_FM LPAREN RPAREN function_body
    (13) function_prototype -> . TYPE var seen_FM LPAREN parameter_list RPAREN SEMICOLON
    (14) function_prototype -> . TYPE var seen_FM LPAREN RPAREN SEMICOLON
    (15) function_prototype -> . VOID NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON
    (16) function_prototype -> . VOID NAME seen_FM LPAREN RPAREN SEMICOLON
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    VOID            shift and go to state 9
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    TYPE                           shift and go to state 1
    block_list                     shift and go to state 3
    declaration                    shift and go to state 4
    function                       shift and go to state 6
    basic_block                    shift and go to state 7
    function_prototype             shift and go to state 8
    program                        shift and go to state 10

state 1

    (80) declaration -> TYPE . varlist SEMICOLON
    (7) function -> TYPE . var seen_FM LPAREN parameter_list RPAREN function_body
    (9) function -> TYPE . var seen_FM LPAREN RPAREN function_body
    (13) function_prototype -> TYPE . var seen_FM LPAREN parameter_list RPAREN SEMICOLON
    (14) function_prototype -> TYPE . var seen_FM LPAREN RPAREN SEMICOLON
    (81) varlist -> . var COMMA varlist
    (82) varlist -> . var
    (83) var -> . STAR var
    (84) var -> . NAME

    STAR            shift and go to state 11
    NAME            shift and go to state 12

    varlist                        shift and go to state 13
    var                            shift and go to state 14

state 2

    (20) TYPE -> FLOAT .

    STAR            reduce using rule 20 (TYPE -> FLOAT .)
    NAME            reduce using rule 20 (TYPE -> FLOAT .)


state 3

    (1) program -> block_list .

    $end            reduce using rule 1 (program -> block_list .)


state 4

    (4) basic_block -> declaration .

    VOID            reduce using rule 4 (basic_block -> declaration .)
    INT             reduce using rule 4 (basic_block -> declaration .)
    FLOAT           reduce using rule 4 (basic_block -> declaration .)
    $end            reduce using rule 4 (basic_block -> declaration .)


state 5

    (19) TYPE -> INT .

    STAR            reduce using rule 19 (TYPE -> INT .)
    NAME            reduce using rule 19 (TYPE -> INT .)


state 6

    (5) basic_block -> function .

    VOID            reduce using rule 5 (basic_block -> function .)
    INT             reduce using rule 5 (basic_block -> function .)
    FLOAT           reduce using rule 5 (basic_block -> function .)
    $end            reduce using rule 5 (basic_block -> function .)


state 7

    (2) block_list -> basic_block . block_list
    (3) block_list -> basic_block .
    (2) block_list -> . basic_block block_list
    (3) block_list -> . basic_block
    (4) basic_block -> . declaration
    (5) basic_block -> . function
    (6) basic_block -> . function_prototype
    (80) declaration -> . TYPE varlist SEMICOLON
    (7) function -> . TYPE var seen_FM LPAREN parameter_list RPAREN function_body
    (8) function -> . VOID NAME seen_FM LPAREN parameter_list RPAREN function_body
    (9) function -> . TYPE var seen_FM LPAREN RPAREN function_body
    (10) function -> . VOID NAME seen_FM LPAREN RPAREN function_body
    (11) function -> . VOID MAIN seen_FM LPAREN RPAREN function_body
    (13) function_prototype -> . TYPE var seen_FM LPAREN parameter_list RPAREN SEMICOLON
    (14) function_prototype -> . TYPE var seen_FM LPAREN RPAREN SEMICOLON
    (15) function_prototype -> . VOID NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON
    (16) function_prototype -> . VOID NAME seen_FM LPAREN RPAREN SEMICOLON
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    $end            reduce using rule 3 (block_list -> basic_block .)
    VOID            shift and go to state 9
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    function                       shift and go to state 6
    TYPE                           shift and go to state 1
    basic_block                    shift and go to state 7
    block_list                     shift and go to state 15
    declaration                    shift and go to state 4
    function_prototype             shift and go to state 8

state 8

    (6) basic_block -> function_prototype .

    VOID            reduce using rule 6 (basic_block -> function_prototype .)
    INT             reduce using rule 6 (basic_block -> function_prototype .)
    FLOAT           reduce using rule 6 (basic_block -> function_prototype .)
    $end            reduce using rule 6 (basic_block -> function_prototype .)


state 9

    (8) function -> VOID . NAME seen_FM LPAREN parameter_list RPAREN function_body
    (10) function -> VOID . NAME seen_FM LPAREN RPAREN function_body
    (11) function -> VOID . MAIN seen_FM LPAREN RPAREN function_body
    (15) function_prototype -> VOID . NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON
    (16) function_prototype -> VOID . NAME seen_FM LPAREN RPAREN SEMICOLON

    NAME            shift and go to state 16
    MAIN            shift and go to state 17


state 10

    (0) S' -> program .



state 11

    (83) var -> STAR . var
    (83) var -> . STAR var
    (84) var -> . NAME

    STAR            shift and go to state 11
    NAME            shift and go to state 12

    var                            shift and go to state 18

state 12

    (84) var -> NAME .

    COMMA           reduce using rule 84 (var -> NAME .)
    LPAREN          reduce using rule 84 (var -> NAME .)
    SEMICOLON       reduce using rule 84 (var -> NAME .)
    RPAREN          reduce using rule 84 (var -> NAME .)


state 13

    (80) declaration -> TYPE varlist . SEMICOLON

    SEMICOLON       shift and go to state 19


state 14

    (7) function -> TYPE var . seen_FM LPAREN parameter_list RPAREN function_body
    (9) function -> TYPE var . seen_FM LPAREN RPAREN function_body
    (13) function_prototype -> TYPE var . seen_FM LPAREN parameter_list RPAREN SEMICOLON
    (14) function_prototype -> TYPE var . seen_FM LPAREN RPAREN SEMICOLON
    (81) varlist -> var . COMMA varlist
    (82) varlist -> var .
    (12) seen_FM -> .

    COMMA           shift and go to state 21
    SEMICOLON       reduce using rule 82 (varlist -> var .)
    LPAREN          reduce using rule 12 (seen_FM -> .)

    seen_FM                        shift and go to state 20

state 15

    (2) block_list -> basic_block block_list .

    $end            reduce using rule 2 (block_list -> basic_block block_list .)


state 16

    (8) function -> VOID NAME . seen_FM LPAREN parameter_list RPAREN function_body
    (10) function -> VOID NAME . seen_FM LPAREN RPAREN function_body
    (15) function_prototype -> VOID NAME . seen_FM LPAREN parameter_list RPAREN SEMICOLON
    (16) function_prototype -> VOID NAME . seen_FM LPAREN RPAREN SEMICOLON
    (12) seen_FM -> .

    LPAREN          reduce using rule 12 (seen_FM -> .)

    seen_FM                        shift and go to state 22

state 17

    (11) function -> VOID MAIN . seen_FM LPAREN RPAREN function_body
    (12) seen_FM -> .

    LPAREN          reduce using rule 12 (seen_FM -> .)

    seen_FM                        shift and go to state 23

state 18

    (83) var -> STAR var .

    COMMA           reduce using rule 83 (var -> STAR var .)
    LPAREN          reduce using rule 83 (var -> STAR var .)
    SEMICOLON       reduce using rule 83 (var -> STAR var .)
    RPAREN          reduce using rule 83 (var -> STAR var .)


state 19

    (80) declaration -> TYPE varlist SEMICOLON .

    IF              reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    WHILE           reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    NAME            reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    STAR            reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    INT             reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    FLOAT           reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    RCURLY          reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    RETURN          reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    VOID            reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    $end            reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)
    ELSE            reduce using rule 80 (declaration -> TYPE varlist SEMICOLON .)


state 20

    (7) function -> TYPE var seen_FM . LPAREN parameter_list RPAREN function_body
    (9) function -> TYPE var seen_FM . LPAREN RPAREN function_body
    (13) function_prototype -> TYPE var seen_FM . LPAREN parameter_list RPAREN SEMICOLON
    (14) function_prototype -> TYPE var seen_FM . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 24


state 21

    (81) varlist -> var COMMA . varlist
    (81) varlist -> . var COMMA varlist
    (82) varlist -> . var
    (83) var -> . STAR var
    (84) var -> . NAME

    STAR            shift and go to state 11
    NAME            shift and go to state 12

    varlist                        shift and go to state 25
    var                            shift and go to state 26

state 22

    (8) function -> VOID NAME seen_FM . LPAREN parameter_list RPAREN function_body
    (10) function -> VOID NAME seen_FM . LPAREN RPAREN function_body
    (15) function_prototype -> VOID NAME seen_FM . LPAREN parameter_list RPAREN SEMICOLON
    (16) function_prototype -> VOID NAME seen_FM . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 27


state 23

    (11) function -> VOID MAIN seen_FM . LPAREN RPAREN function_body

    LPAREN          shift and go to state 28


state 24

    (7) function -> TYPE var seen_FM LPAREN . parameter_list RPAREN function_body
    (9) function -> TYPE var seen_FM LPAREN . RPAREN function_body
    (13) function_prototype -> TYPE var seen_FM LPAREN . parameter_list RPAREN SEMICOLON
    (14) function_prototype -> TYPE var seen_FM LPAREN . RPAREN SEMICOLON
    (17) parameter_list -> . TYPE var COMMA parameter_list
    (18) parameter_list -> . TYPE var
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    RPAREN          shift and go to state 31
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    TYPE                           shift and go to state 29
    parameter_list                 shift and go to state 30

state 25

    (81) varlist -> var COMMA varlist .

    SEMICOLON       reduce using rule 81 (varlist -> var COMMA varlist .)


state 26

    (81) varlist -> var . COMMA varlist
    (82) varlist -> var .

    COMMA           shift and go to state 21
    SEMICOLON       reduce using rule 82 (varlist -> var .)


state 27

    (8) function -> VOID NAME seen_FM LPAREN . parameter_list RPAREN function_body
    (10) function -> VOID NAME seen_FM LPAREN . RPAREN function_body
    (15) function_prototype -> VOID NAME seen_FM LPAREN . parameter_list RPAREN SEMICOLON
    (16) function_prototype -> VOID NAME seen_FM LPAREN . RPAREN SEMICOLON
    (17) parameter_list -> . TYPE var COMMA parameter_list
    (18) parameter_list -> . TYPE var
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    RPAREN          shift and go to state 32
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    parameter_list                 shift and go to state 33
    TYPE                           shift and go to state 29

state 28

    (11) function -> VOID MAIN seen_FM LPAREN . RPAREN function_body

    RPAREN          shift and go to state 34


state 29

    (17) parameter_list -> TYPE . var COMMA parameter_list
    (18) parameter_list -> TYPE . var
    (83) var -> . STAR var
    (84) var -> . NAME

    STAR            shift and go to state 11
    NAME            shift and go to state 12

    var                            shift and go to state 35

state 30

    (7) function -> TYPE var seen_FM LPAREN parameter_list . RPAREN function_body
    (13) function_prototype -> TYPE var seen_FM LPAREN parameter_list . RPAREN SEMICOLON

    RPAREN          shift and go to state 36


state 31

    (9) function -> TYPE var seen_FM LPAREN RPAREN . function_body
    (14) function_prototype -> TYPE var seen_FM LPAREN RPAREN . SEMICOLON
    (21) function_body -> . LCURLY stmt_list return_stmt RCURLY
    (22) function_body -> . LCURLY return_stmt RCURLY
    (23) function_body -> . body
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY

    SEMICOLON       shift and go to state 40
    LCURLY          shift and go to state 37

    body                           shift and go to state 39
    function_body                  shift and go to state 38

state 32

    (10) function -> VOID NAME seen_FM LPAREN RPAREN . function_body
    (16) function_prototype -> VOID NAME seen_FM LPAREN RPAREN . SEMICOLON
    (21) function_body -> . LCURLY stmt_list return_stmt RCURLY
    (22) function_body -> . LCURLY return_stmt RCURLY
    (23) function_body -> . body
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY

    SEMICOLON       shift and go to state 42
    LCURLY          shift and go to state 37

    function_body                  shift and go to state 41
    body                           shift and go to state 39

state 33

    (8) function -> VOID NAME seen_FM LPAREN parameter_list . RPAREN function_body
    (15) function_prototype -> VOID NAME seen_FM LPAREN parameter_list . RPAREN SEMICOLON

    RPAREN          shift and go to state 43


state 34

    (11) function -> VOID MAIN seen_FM LPAREN RPAREN . function_body
    (21) function_body -> . LCURLY stmt_list return_stmt RCURLY
    (22) function_body -> . LCURLY return_stmt RCURLY
    (23) function_body -> . body
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY

    LCURLY          shift and go to state 37

    function_body                  shift and go to state 44
    body                           shift and go to state 39

state 35

    (17) parameter_list -> TYPE var . COMMA parameter_list
    (18) parameter_list -> TYPE var .

    COMMA           shift and go to state 45
    RPAREN          reduce using rule 18 (parameter_list -> TYPE var .)


state 36

    (7) function -> TYPE var seen_FM LPAREN parameter_list RPAREN . function_body
    (13) function_prototype -> TYPE var seen_FM LPAREN parameter_list RPAREN . SEMICOLON
    (21) function_body -> . LCURLY stmt_list return_stmt RCURLY
    (22) function_body -> . LCURLY return_stmt RCURLY
    (23) function_body -> . body
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY

    SEMICOLON       shift and go to state 47
    LCURLY          shift and go to state 37

    body                           shift and go to state 39
    function_body                  shift and go to state 46

state 37

    (21) function_body -> LCURLY . stmt_list return_stmt RCURLY
    (22) function_body -> LCURLY . return_stmt RCURLY
    (26) body -> LCURLY . stmt_list RCURLY
    (27) body -> LCURLY . RCURLY
    (28) stmt_list -> . stmt stmt_list
    (29) stmt_list -> . stmt
    (24) return_stmt -> . RETURN SEMICOLON
    (25) return_stmt -> . RETURN R2 SEMICOLON
    (30) stmt -> . matched_stmt
    (31) stmt -> . unmatched_stmt
    (32) matched_stmt -> . assign
    (33) matched_stmt -> . declaration
    (34) matched_stmt -> . matched_decision
    (35) matched_stmt -> . matched_loop
    (36) matched_stmt -> . function_call SEMICOLON
    (37) unmatched_stmt -> . unmatched_decision
    (38) unmatched_stmt -> . unmatched_loop
    (39) assign -> . L1 EQUALS R1 SEMICOLON
    (40) assign -> . L2 EQUALS R2 SEMICOLON
    (80) declaration -> . TYPE varlist SEMICOLON
    (99) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> . IF LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> . IF LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> . IF LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (85) matched_loop -> . WHILE LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> . WHILE LPAREN condition RPAREN body
    (87) matched_loop -> . WHILE LPAREN condition RPAREN SEMICOLON
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN
    (108) unmatched_decision -> . IF LPAREN condition RPAREN stmt
    (109) unmatched_decision -> . IF LPAREN condition RPAREN body
    (110) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> . IF LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt
    (88) unmatched_loop -> . WHILE LPAREN condition RPAREN unmatched_stmt
    (41) L1 -> . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    RCURLY          shift and go to state 48
    RETURN          shift and go to state 61
    IF              shift and go to state 55
    WHILE           shift and go to state 66
    NAME            shift and go to state 59
    STAR            shift and go to state 52
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    matched_loop                   shift and go to state 62
    return_stmt                    shift and go to state 57
    L2                             shift and go to state 49
    TYPE                           shift and go to state 56
    unmatched_decision             shift and go to state 51
    function_call                  shift and go to state 58
    declaration                    shift and go to state 50
    matched_stmt                   shift and go to state 60
    matched_decision               shift and go to state 53
    unmatched_loop                 shift and go to state 63
    stmt_list                      shift and go to state 64
    stmt                           shift and go to state 65
    assign                         shift and go to state 54
    unmatched_stmt                 shift and go to state 67
    L1                             shift and go to state 68

state 38

    (9) function -> TYPE var seen_FM LPAREN RPAREN function_body .

    VOID            reduce using rule 9 (function -> TYPE var seen_FM LPAREN RPAREN function_body .)
    INT             reduce using rule 9 (function -> TYPE var seen_FM LPAREN RPAREN function_body .)
    FLOAT           reduce using rule 9 (function -> TYPE var seen_FM LPAREN RPAREN function_body .)
    $end            reduce using rule 9 (function -> TYPE var seen_FM LPAREN RPAREN function_body .)


state 39

    (23) function_body -> body .

    VOID            reduce using rule 23 (function_body -> body .)
    INT             reduce using rule 23 (function_body -> body .)
    FLOAT           reduce using rule 23 (function_body -> body .)
    $end            reduce using rule 23 (function_body -> body .)


state 40

    (14) function_prototype -> TYPE var seen_FM LPAREN RPAREN SEMICOLON .

    VOID            reduce using rule 14 (function_prototype -> TYPE var seen_FM LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 14 (function_prototype -> TYPE var seen_FM LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 14 (function_prototype -> TYPE var seen_FM LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 14 (function_prototype -> TYPE var seen_FM LPAREN RPAREN SEMICOLON .)


state 41

    (10) function -> VOID NAME seen_FM LPAREN RPAREN function_body .

    VOID            reduce using rule 10 (function -> VOID NAME seen_FM LPAREN RPAREN function_body .)
    INT             reduce using rule 10 (function -> VOID NAME seen_FM LPAREN RPAREN function_body .)
    FLOAT           reduce using rule 10 (function -> VOID NAME seen_FM LPAREN RPAREN function_body .)
    $end            reduce using rule 10 (function -> VOID NAME seen_FM LPAREN RPAREN function_body .)


state 42

    (16) function_prototype -> VOID NAME seen_FM LPAREN RPAREN SEMICOLON .

    VOID            reduce using rule 16 (function_prototype -> VOID NAME seen_FM LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 16 (function_prototype -> VOID NAME seen_FM LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 16 (function_prototype -> VOID NAME seen_FM LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 16 (function_prototype -> VOID NAME seen_FM LPAREN RPAREN SEMICOLON .)


state 43

    (8) function -> VOID NAME seen_FM LPAREN parameter_list RPAREN . function_body
    (15) function_prototype -> VOID NAME seen_FM LPAREN parameter_list RPAREN . SEMICOLON
    (21) function_body -> . LCURLY stmt_list return_stmt RCURLY
    (22) function_body -> . LCURLY return_stmt RCURLY
    (23) function_body -> . body
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY

    SEMICOLON       shift and go to state 70
    LCURLY          shift and go to state 37

    function_body                  shift and go to state 69
    body                           shift and go to state 39

state 44

    (11) function -> VOID MAIN seen_FM LPAREN RPAREN function_body .

    VOID            reduce using rule 11 (function -> VOID MAIN seen_FM LPAREN RPAREN function_body .)
    INT             reduce using rule 11 (function -> VOID MAIN seen_FM LPAREN RPAREN function_body .)
    FLOAT           reduce using rule 11 (function -> VOID MAIN seen_FM LPAREN RPAREN function_body .)
    $end            reduce using rule 11 (function -> VOID MAIN seen_FM LPAREN RPAREN function_body .)


state 45

    (17) parameter_list -> TYPE var COMMA . parameter_list
    (17) parameter_list -> . TYPE var COMMA parameter_list
    (18) parameter_list -> . TYPE var
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    TYPE                           shift and go to state 29
    parameter_list                 shift and go to state 71

state 46

    (7) function -> TYPE var seen_FM LPAREN parameter_list RPAREN function_body .

    VOID            reduce using rule 7 (function -> TYPE var seen_FM LPAREN parameter_list RPAREN function_body .)
    INT             reduce using rule 7 (function -> TYPE var seen_FM LPAREN parameter_list RPAREN function_body .)
    FLOAT           reduce using rule 7 (function -> TYPE var seen_FM LPAREN parameter_list RPAREN function_body .)
    $end            reduce using rule 7 (function -> TYPE var seen_FM LPAREN parameter_list RPAREN function_body .)


state 47

    (13) function_prototype -> TYPE var seen_FM LPAREN parameter_list RPAREN SEMICOLON .

    VOID            reduce using rule 13 (function_prototype -> TYPE var seen_FM LPAREN parameter_list RPAREN SEMICOLON .)
    INT             reduce using rule 13 (function_prototype -> TYPE var seen_FM LPAREN parameter_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 13 (function_prototype -> TYPE var seen_FM LPAREN parameter_list RPAREN SEMICOLON .)
    $end            reduce using rule 13 (function_prototype -> TYPE var seen_FM LPAREN parameter_list RPAREN SEMICOLON .)


state 48

    (27) body -> LCURLY RCURLY .

    VOID            reduce using rule 27 (body -> LCURLY RCURLY .)
    INT             reduce using rule 27 (body -> LCURLY RCURLY .)
    FLOAT           reduce using rule 27 (body -> LCURLY RCURLY .)
    $end            reduce using rule 27 (body -> LCURLY RCURLY .)
    IF              reduce using rule 27 (body -> LCURLY RCURLY .)
    WHILE           reduce using rule 27 (body -> LCURLY RCURLY .)
    NAME            reduce using rule 27 (body -> LCURLY RCURLY .)
    STAR            reduce using rule 27 (body -> LCURLY RCURLY .)
    RCURLY          reduce using rule 27 (body -> LCURLY RCURLY .)
    RETURN          reduce using rule 27 (body -> LCURLY RCURLY .)
    ELSE            reduce using rule 27 (body -> LCURLY RCURLY .)


state 49

    (40) assign -> L2 . EQUALS R2 SEMICOLON

    EQUALS          shift and go to state 72


state 50

    (33) matched_stmt -> declaration .

    IF              reduce using rule 33 (matched_stmt -> declaration .)
    WHILE           reduce using rule 33 (matched_stmt -> declaration .)
    NAME            reduce using rule 33 (matched_stmt -> declaration .)
    STAR            reduce using rule 33 (matched_stmt -> declaration .)
    INT             reduce using rule 33 (matched_stmt -> declaration .)
    FLOAT           reduce using rule 33 (matched_stmt -> declaration .)
    RCURLY          reduce using rule 33 (matched_stmt -> declaration .)
    RETURN          reduce using rule 33 (matched_stmt -> declaration .)
    ELSE            reduce using rule 33 (matched_stmt -> declaration .)


state 51

    (37) unmatched_stmt -> unmatched_decision .

    IF              reduce using rule 37 (unmatched_stmt -> unmatched_decision .)
    WHILE           reduce using rule 37 (unmatched_stmt -> unmatched_decision .)
    NAME            reduce using rule 37 (unmatched_stmt -> unmatched_decision .)
    STAR            reduce using rule 37 (unmatched_stmt -> unmatched_decision .)
    INT             reduce using rule 37 (unmatched_stmt -> unmatched_decision .)
    FLOAT           reduce using rule 37 (unmatched_stmt -> unmatched_decision .)
    RCURLY          reduce using rule 37 (unmatched_stmt -> unmatched_decision .)
    RETURN          reduce using rule 37 (unmatched_stmt -> unmatched_decision .)


state 52

    (61) L2 -> STAR . L2
    (62) L2 -> STAR . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME

    NAME            shift and go to state 73
    STAR            shift and go to state 52

    L2                             shift and go to state 74

state 53

    (34) matched_stmt -> matched_decision .

    IF              reduce using rule 34 (matched_stmt -> matched_decision .)
    WHILE           reduce using rule 34 (matched_stmt -> matched_decision .)
    NAME            reduce using rule 34 (matched_stmt -> matched_decision .)
    STAR            reduce using rule 34 (matched_stmt -> matched_decision .)
    INT             reduce using rule 34 (matched_stmt -> matched_decision .)
    FLOAT           reduce using rule 34 (matched_stmt -> matched_decision .)
    RCURLY          reduce using rule 34 (matched_stmt -> matched_decision .)
    RETURN          reduce using rule 34 (matched_stmt -> matched_decision .)
    ELSE            reduce using rule 34 (matched_stmt -> matched_decision .)


state 54

    (32) matched_stmt -> assign .

    IF              reduce using rule 32 (matched_stmt -> assign .)
    WHILE           reduce using rule 32 (matched_stmt -> assign .)
    NAME            reduce using rule 32 (matched_stmt -> assign .)
    STAR            reduce using rule 32 (matched_stmt -> assign .)
    INT             reduce using rule 32 (matched_stmt -> assign .)
    FLOAT           reduce using rule 32 (matched_stmt -> assign .)
    RCURLY          reduce using rule 32 (matched_stmt -> assign .)
    RETURN          reduce using rule 32 (matched_stmt -> assign .)
    ELSE            reduce using rule 32 (matched_stmt -> assign .)


state 55

    (99) matched_decision -> IF . LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> IF . LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> IF . LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> IF . LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> IF . LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> IF . LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> IF . LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> IF . LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> IF . LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (108) unmatched_decision -> IF . LPAREN condition RPAREN stmt
    (109) unmatched_decision -> IF . LPAREN condition RPAREN body
    (110) unmatched_decision -> IF . LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> IF . LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> IF . LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> IF . LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt

    LPAREN          shift and go to state 75


state 56

    (80) declaration -> TYPE . varlist SEMICOLON
    (81) varlist -> . var COMMA varlist
    (82) varlist -> . var
    (83) var -> . STAR var
    (84) var -> . NAME

    STAR            shift and go to state 11
    NAME            shift and go to state 12

    varlist                        shift and go to state 13
    var                            shift and go to state 26

state 57

    (22) function_body -> LCURLY return_stmt . RCURLY

    RCURLY          shift and go to state 76


state 58

    (36) matched_stmt -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 77


state 59

    (76) function_call -> NAME . LPAREN arg_list RPAREN
    (77) function_call -> NAME . LPAREN RPAREN
    (41) L1 -> NAME .

    LPAREN          shift and go to state 78
    EQUALS          reduce using rule 41 (L1 -> NAME .)


state 60

    (30) stmt -> matched_stmt .

    IF              reduce using rule 30 (stmt -> matched_stmt .)
    WHILE           reduce using rule 30 (stmt -> matched_stmt .)
    NAME            reduce using rule 30 (stmt -> matched_stmt .)
    STAR            reduce using rule 30 (stmt -> matched_stmt .)
    INT             reduce using rule 30 (stmt -> matched_stmt .)
    FLOAT           reduce using rule 30 (stmt -> matched_stmt .)
    RCURLY          reduce using rule 30 (stmt -> matched_stmt .)
    RETURN          reduce using rule 30 (stmt -> matched_stmt .)


state 61

    (24) return_stmt -> RETURN . SEMICOLON
    (25) return_stmt -> RETURN . R2 SEMICOLON
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    SEMICOLON       shift and go to state 84
    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 87

state 62

    (35) matched_stmt -> matched_loop .

    IF              reduce using rule 35 (matched_stmt -> matched_loop .)
    WHILE           reduce using rule 35 (matched_stmt -> matched_loop .)
    NAME            reduce using rule 35 (matched_stmt -> matched_loop .)
    STAR            reduce using rule 35 (matched_stmt -> matched_loop .)
    INT             reduce using rule 35 (matched_stmt -> matched_loop .)
    FLOAT           reduce using rule 35 (matched_stmt -> matched_loop .)
    RCURLY          reduce using rule 35 (matched_stmt -> matched_loop .)
    RETURN          reduce using rule 35 (matched_stmt -> matched_loop .)
    ELSE            reduce using rule 35 (matched_stmt -> matched_loop .)


state 63

    (38) unmatched_stmt -> unmatched_loop .

    IF              reduce using rule 38 (unmatched_stmt -> unmatched_loop .)
    WHILE           reduce using rule 38 (unmatched_stmt -> unmatched_loop .)
    NAME            reduce using rule 38 (unmatched_stmt -> unmatched_loop .)
    STAR            reduce using rule 38 (unmatched_stmt -> unmatched_loop .)
    INT             reduce using rule 38 (unmatched_stmt -> unmatched_loop .)
    FLOAT           reduce using rule 38 (unmatched_stmt -> unmatched_loop .)
    RCURLY          reduce using rule 38 (unmatched_stmt -> unmatched_loop .)
    RETURN          reduce using rule 38 (unmatched_stmt -> unmatched_loop .)


state 64

    (21) function_body -> LCURLY stmt_list . return_stmt RCURLY
    (26) body -> LCURLY stmt_list . RCURLY
    (24) return_stmt -> . RETURN SEMICOLON
    (25) return_stmt -> . RETURN R2 SEMICOLON

    RCURLY          shift and go to state 89
    RETURN          shift and go to state 61

    return_stmt                    shift and go to state 90

state 65

    (28) stmt_list -> stmt . stmt_list
    (29) stmt_list -> stmt .
    (28) stmt_list -> . stmt stmt_list
    (29) stmt_list -> . stmt
    (30) stmt -> . matched_stmt
    (31) stmt -> . unmatched_stmt
    (32) matched_stmt -> . assign
    (33) matched_stmt -> . declaration
    (34) matched_stmt -> . matched_decision
    (35) matched_stmt -> . matched_loop
    (36) matched_stmt -> . function_call SEMICOLON
    (37) unmatched_stmt -> . unmatched_decision
    (38) unmatched_stmt -> . unmatched_loop
    (39) assign -> . L1 EQUALS R1 SEMICOLON
    (40) assign -> . L2 EQUALS R2 SEMICOLON
    (80) declaration -> . TYPE varlist SEMICOLON
    (99) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> . IF LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> . IF LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> . IF LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (85) matched_loop -> . WHILE LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> . WHILE LPAREN condition RPAREN body
    (87) matched_loop -> . WHILE LPAREN condition RPAREN SEMICOLON
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN
    (108) unmatched_decision -> . IF LPAREN condition RPAREN stmt
    (109) unmatched_decision -> . IF LPAREN condition RPAREN body
    (110) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> . IF LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt
    (88) unmatched_loop -> . WHILE LPAREN condition RPAREN unmatched_stmt
    (41) L1 -> . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    RCURLY          reduce using rule 29 (stmt_list -> stmt .)
    RETURN          reduce using rule 29 (stmt_list -> stmt .)
    IF              shift and go to state 55
    WHILE           shift and go to state 66
    NAME            shift and go to state 59
    STAR            shift and go to state 52
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    matched_stmt                   shift and go to state 60
    L2                             shift and go to state 49
    TYPE                           shift and go to state 56
    function_call                  shift and go to state 58
    declaration                    shift and go to state 50
    unmatched_decision             shift and go to state 51
    matched_loop                   shift and go to state 62
    unmatched_loop                 shift and go to state 63
    matched_decision               shift and go to state 53
    stmt_list                      shift and go to state 91
    stmt                           shift and go to state 65
    assign                         shift and go to state 54
    unmatched_stmt                 shift and go to state 67
    L1                             shift and go to state 68

state 66

    (85) matched_loop -> WHILE . LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> WHILE . LPAREN condition RPAREN body
    (87) matched_loop -> WHILE . LPAREN condition RPAREN SEMICOLON
    (88) unmatched_loop -> WHILE . LPAREN condition RPAREN unmatched_stmt

    LPAREN          shift and go to state 92


state 67

    (31) stmt -> unmatched_stmt .

    IF              reduce using rule 31 (stmt -> unmatched_stmt .)
    WHILE           reduce using rule 31 (stmt -> unmatched_stmt .)
    NAME            reduce using rule 31 (stmt -> unmatched_stmt .)
    STAR            reduce using rule 31 (stmt -> unmatched_stmt .)
    INT             reduce using rule 31 (stmt -> unmatched_stmt .)
    FLOAT           reduce using rule 31 (stmt -> unmatched_stmt .)
    RCURLY          reduce using rule 31 (stmt -> unmatched_stmt .)
    RETURN          reduce using rule 31 (stmt -> unmatched_stmt .)


state 68

    (39) assign -> L1 . EQUALS R1 SEMICOLON

    EQUALS          shift and go to state 93


state 69

    (8) function -> VOID NAME seen_FM LPAREN parameter_list RPAREN function_body .

    VOID            reduce using rule 8 (function -> VOID NAME seen_FM LPAREN parameter_list RPAREN function_body .)
    INT             reduce using rule 8 (function -> VOID NAME seen_FM LPAREN parameter_list RPAREN function_body .)
    FLOAT           reduce using rule 8 (function -> VOID NAME seen_FM LPAREN parameter_list RPAREN function_body .)
    $end            reduce using rule 8 (function -> VOID NAME seen_FM LPAREN parameter_list RPAREN function_body .)


state 70

    (15) function_prototype -> VOID NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON .

    VOID            reduce using rule 15 (function_prototype -> VOID NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON .)
    INT             reduce using rule 15 (function_prototype -> VOID NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 15 (function_prototype -> VOID NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON .)
    $end            reduce using rule 15 (function_prototype -> VOID NAME seen_FM LPAREN parameter_list RPAREN SEMICOLON .)


state 71

    (17) parameter_list -> TYPE var COMMA parameter_list .

    RPAREN          reduce using rule 17 (parameter_list -> TYPE var COMMA parameter_list .)


state 72

    (40) assign -> L2 EQUALS . R2 SEMICOLON
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 94

state 73

    (62) L2 -> STAR NAME .

    EQUALS          reduce using rule 62 (L2 -> STAR NAME .)


state 74

    (61) L2 -> STAR L2 .

    EQUALS          reduce using rule 61 (L2 -> STAR L2 .)


state 75

    (99) matched_decision -> IF LPAREN . condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> IF LPAREN . condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> IF LPAREN . condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> IF LPAREN . condition RPAREN body ELSE body
    (103) matched_decision -> IF LPAREN . condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> IF LPAREN . condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> IF LPAREN . condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> IF LPAREN . condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> IF LPAREN . condition RPAREN SEMICOLON ELSE SEMICOLON
    (108) unmatched_decision -> IF LPAREN . condition RPAREN stmt
    (109) unmatched_decision -> IF LPAREN . condition RPAREN body
    (110) unmatched_decision -> IF LPAREN . condition RPAREN SEMICOLON
    (111) unmatched_decision -> IF LPAREN . condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> IF LPAREN . condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> IF LPAREN . condition RPAREN SEMICOLON ELSE unmatched_stmt
    (89) condition -> . condition AND condition
    (90) condition -> . condition OR condition
    (91) condition -> . LPAREN condition RPAREN
    (92) condition -> . NOT condition
    (93) condition -> . R2 GT R2
    (94) condition -> . R2 LT R2
    (95) condition -> . R2 GE R2
    (96) condition -> . R2 LE R2
    (97) condition -> . R2 EQ R2
    (98) condition -> . R2 NE R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 97
    NOT             shift and go to state 98
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    condition                      shift and go to state 95
    PName                          shift and go to state 88
    R2                             shift and go to state 96

state 76

    (22) function_body -> LCURLY return_stmt RCURLY .

    VOID            reduce using rule 22 (function_body -> LCURLY return_stmt RCURLY .)
    INT             reduce using rule 22 (function_body -> LCURLY return_stmt RCURLY .)
    FLOAT           reduce using rule 22 (function_body -> LCURLY return_stmt RCURLY .)
    $end            reduce using rule 22 (function_body -> LCURLY return_stmt RCURLY .)


state 77

    (36) matched_stmt -> function_call SEMICOLON .

    IF              reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)
    WHILE           reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)
    NAME            reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)
    STAR            reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)
    INT             reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)
    FLOAT           reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)
    RCURLY          reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)
    RETURN          reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)
    ELSE            reduce using rule 36 (matched_stmt -> function_call SEMICOLON .)


state 78

    (76) function_call -> NAME LPAREN . arg_list RPAREN
    (77) function_call -> NAME LPAREN . RPAREN
    (78) arg_list -> . R2 COMMA arg_list
    (79) arg_list -> . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    RPAREN          shift and go to state 101
    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    arg_list                       shift and go to state 99
    R2                             shift and go to state 100

state 79

    (73) PName -> STAR . PName
    (74) PName -> STAR . NAME
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME

    NAME            shift and go to state 103
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    PName                          shift and go to state 102

state 80

    (70) R2 -> function_call .

    PLUS            reduce using rule 70 (R2 -> function_call .)
    MINUS           reduce using rule 70 (R2 -> function_call .)
    STAR            reduce using rule 70 (R2 -> function_call .)
    DIVIDE          reduce using rule 70 (R2 -> function_call .)
    SEMICOLON       reduce using rule 70 (R2 -> function_call .)
    GT              reduce using rule 70 (R2 -> function_call .)
    LT              reduce using rule 70 (R2 -> function_call .)
    GE              reduce using rule 70 (R2 -> function_call .)
    LE              reduce using rule 70 (R2 -> function_call .)
    EQ              reduce using rule 70 (R2 -> function_call .)
    NE              reduce using rule 70 (R2 -> function_call .)
    COMMA           reduce using rule 70 (R2 -> function_call .)
    RPAREN          reduce using rule 70 (R2 -> function_call .)
    AND             reduce using rule 70 (R2 -> function_call .)
    OR              reduce using rule 70 (R2 -> function_call .)


state 81

    (71) R2 -> NAME .
    (76) function_call -> NAME . LPAREN arg_list RPAREN
    (77) function_call -> NAME . LPAREN RPAREN

    PLUS            reduce using rule 71 (R2 -> NAME .)
    MINUS           reduce using rule 71 (R2 -> NAME .)
    STAR            reduce using rule 71 (R2 -> NAME .)
    DIVIDE          reduce using rule 71 (R2 -> NAME .)
    SEMICOLON       reduce using rule 71 (R2 -> NAME .)
    GT              reduce using rule 71 (R2 -> NAME .)
    LT              reduce using rule 71 (R2 -> NAME .)
    GE              reduce using rule 71 (R2 -> NAME .)
    LE              reduce using rule 71 (R2 -> NAME .)
    EQ              reduce using rule 71 (R2 -> NAME .)
    NE              reduce using rule 71 (R2 -> NAME .)
    COMMA           reduce using rule 71 (R2 -> NAME .)
    RPAREN          reduce using rule 71 (R2 -> NAME .)
    AND             reduce using rule 71 (R2 -> NAME .)
    OR              reduce using rule 71 (R2 -> NAME .)
    LPAREN          shift and go to state 78


state 82

    (72) R2 -> NUMBER .

    PLUS            reduce using rule 72 (R2 -> NUMBER .)
    MINUS           reduce using rule 72 (R2 -> NUMBER .)
    STAR            reduce using rule 72 (R2 -> NUMBER .)
    DIVIDE          reduce using rule 72 (R2 -> NUMBER .)
    SEMICOLON       reduce using rule 72 (R2 -> NUMBER .)
    GT              reduce using rule 72 (R2 -> NUMBER .)
    LT              reduce using rule 72 (R2 -> NUMBER .)
    GE              reduce using rule 72 (R2 -> NUMBER .)
    LE              reduce using rule 72 (R2 -> NUMBER .)
    EQ              reduce using rule 72 (R2 -> NUMBER .)
    NE              reduce using rule 72 (R2 -> NUMBER .)
    COMMA           reduce using rule 72 (R2 -> NUMBER .)
    RPAREN          reduce using rule 72 (R2 -> NUMBER .)
    AND             reduce using rule 72 (R2 -> NUMBER .)
    OR              reduce using rule 72 (R2 -> NUMBER .)


state 83

    (75) PName -> AMPERSAND . NAME

    NAME            shift and go to state 104


state 84

    (24) return_stmt -> RETURN SEMICOLON .

    RCURLY          reduce using rule 24 (return_stmt -> RETURN SEMICOLON .)


state 85

    (68) R2 -> MINUS . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 105

state 86

    (67) R2 -> LPAREN . R2 RPAREN
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 106

state 87

    (25) return_stmt -> RETURN R2 . SEMICOLON
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    SEMICOLON       shift and go to state 108
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 88

    (69) R2 -> PName .

    PLUS            reduce using rule 69 (R2 -> PName .)
    MINUS           reduce using rule 69 (R2 -> PName .)
    STAR            reduce using rule 69 (R2 -> PName .)
    DIVIDE          reduce using rule 69 (R2 -> PName .)
    SEMICOLON       reduce using rule 69 (R2 -> PName .)
    GT              reduce using rule 69 (R2 -> PName .)
    LT              reduce using rule 69 (R2 -> PName .)
    GE              reduce using rule 69 (R2 -> PName .)
    LE              reduce using rule 69 (R2 -> PName .)
    EQ              reduce using rule 69 (R2 -> PName .)
    NE              reduce using rule 69 (R2 -> PName .)
    COMMA           reduce using rule 69 (R2 -> PName .)
    RPAREN          reduce using rule 69 (R2 -> PName .)
    AND             reduce using rule 69 (R2 -> PName .)
    OR              reduce using rule 69 (R2 -> PName .)


state 89

    (26) body -> LCURLY stmt_list RCURLY .

    VOID            reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    INT             reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    FLOAT           reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    $end            reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    IF              reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    WHILE           reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    NAME            reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    STAR            reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    RCURLY          reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    RETURN          reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)
    ELSE            reduce using rule 26 (body -> LCURLY stmt_list RCURLY .)


state 90

    (21) function_body -> LCURLY stmt_list return_stmt . RCURLY

    RCURLY          shift and go to state 112


state 91

    (28) stmt_list -> stmt stmt_list .

    RCURLY          reduce using rule 28 (stmt_list -> stmt stmt_list .)
    RETURN          reduce using rule 28 (stmt_list -> stmt stmt_list .)


state 92

    (85) matched_loop -> WHILE LPAREN . condition RPAREN matched_stmt
    (86) matched_loop -> WHILE LPAREN . condition RPAREN body
    (87) matched_loop -> WHILE LPAREN . condition RPAREN SEMICOLON
    (88) unmatched_loop -> WHILE LPAREN . condition RPAREN unmatched_stmt
    (89) condition -> . condition AND condition
    (90) condition -> . condition OR condition
    (91) condition -> . LPAREN condition RPAREN
    (92) condition -> . NOT condition
    (93) condition -> . R2 GT R2
    (94) condition -> . R2 LT R2
    (95) condition -> . R2 GE R2
    (96) condition -> . R2 LE R2
    (97) condition -> . R2 EQ R2
    (98) condition -> . R2 NE R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 97
    NOT             shift and go to state 98
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    condition                      shift and go to state 113
    PName                          shift and go to state 88
    R2                             shift and go to state 96

state 93

    (39) assign -> L1 EQUALS . R1 SEMICOLON
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 120
    MINUS           shift and go to state 119
    NAME            shift and go to state 116
    NUMBER          shift and go to state 118
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 117
    R1                             shift and go to state 114
    function_call                  shift and go to state 115
    PName                          shift and go to state 121

state 94

    (40) assign -> L2 EQUALS R2 . SEMICOLON
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    SEMICOLON       shift and go to state 122
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 95

    (99) matched_decision -> IF LPAREN condition . RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> IF LPAREN condition . RPAREN matched_stmt ELSE body
    (101) matched_decision -> IF LPAREN condition . RPAREN body ELSE matched_stmt
    (102) matched_decision -> IF LPAREN condition . RPAREN body ELSE body
    (103) matched_decision -> IF LPAREN condition . RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> IF LPAREN condition . RPAREN body ELSE SEMICOLON
    (105) matched_decision -> IF LPAREN condition . RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> IF LPAREN condition . RPAREN SEMICOLON ELSE body
    (107) matched_decision -> IF LPAREN condition . RPAREN SEMICOLON ELSE SEMICOLON
    (108) unmatched_decision -> IF LPAREN condition . RPAREN stmt
    (109) unmatched_decision -> IF LPAREN condition . RPAREN body
    (110) unmatched_decision -> IF LPAREN condition . RPAREN SEMICOLON
    (111) unmatched_decision -> IF LPAREN condition . RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> IF LPAREN condition . RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> IF LPAREN condition . RPAREN SEMICOLON ELSE unmatched_stmt
    (89) condition -> condition . AND condition
    (90) condition -> condition . OR condition

    RPAREN          shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 123


state 96

    (93) condition -> R2 . GT R2
    (94) condition -> R2 . LT R2
    (95) condition -> R2 . GE R2
    (96) condition -> R2 . LE R2
    (97) condition -> R2 . EQ R2
    (98) condition -> R2 . NE R2
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    GT              shift and go to state 126
    LT              shift and go to state 131
    GE              shift and go to state 127
    LE              shift and go to state 130
    EQ              shift and go to state 129
    NE              shift and go to state 128
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 97

    (91) condition -> LPAREN . condition RPAREN
    (67) R2 -> LPAREN . R2 RPAREN
    (89) condition -> . condition AND condition
    (90) condition -> . condition OR condition
    (91) condition -> . LPAREN condition RPAREN
    (92) condition -> . NOT condition
    (93) condition -> . R2 GT R2
    (94) condition -> . R2 LT R2
    (95) condition -> . R2 GE R2
    (96) condition -> . R2 LE R2
    (97) condition -> . R2 EQ R2
    (98) condition -> . R2 NE R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 97
    NOT             shift and go to state 98
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    condition                      shift and go to state 132
    PName                          shift and go to state 88
    R2                             shift and go to state 133

state 98

    (92) condition -> NOT . condition
    (89) condition -> . condition AND condition
    (90) condition -> . condition OR condition
    (91) condition -> . LPAREN condition RPAREN
    (92) condition -> . NOT condition
    (93) condition -> . R2 GT R2
    (94) condition -> . R2 LT R2
    (95) condition -> . R2 GE R2
    (96) condition -> . R2 LE R2
    (97) condition -> . R2 EQ R2
    (98) condition -> . R2 NE R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 97
    NOT             shift and go to state 98
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    condition                      shift and go to state 134
    PName                          shift and go to state 88
    R2                             shift and go to state 96

state 99

    (76) function_call -> NAME LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 135


state 100

    (78) arg_list -> R2 . COMMA arg_list
    (79) arg_list -> R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    COMMA           shift and go to state 136
    RPAREN          reduce using rule 79 (arg_list -> R2 .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 101

    (77) function_call -> NAME LPAREN RPAREN .

    PLUS            reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    MINUS           reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    STAR            reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    DIVIDE          reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    SEMICOLON       reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    RPAREN          reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    GT              reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    LT              reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    GE              reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    LE              reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    EQ              reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    NE              reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    COMMA           reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    AND             reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)
    OR              reduce using rule 77 (function_call -> NAME LPAREN RPAREN .)


state 102

    (73) PName -> STAR PName .

    SEMICOLON       reduce using rule 73 (PName -> STAR PName .)
    PLUS            reduce using rule 73 (PName -> STAR PName .)
    MINUS           reduce using rule 73 (PName -> STAR PName .)
    STAR            reduce using rule 73 (PName -> STAR PName .)
    DIVIDE          reduce using rule 73 (PName -> STAR PName .)
    RPAREN          reduce using rule 73 (PName -> STAR PName .)
    AND             reduce using rule 73 (PName -> STAR PName .)
    OR              reduce using rule 73 (PName -> STAR PName .)
    GT              reduce using rule 73 (PName -> STAR PName .)
    LT              reduce using rule 73 (PName -> STAR PName .)
    GE              reduce using rule 73 (PName -> STAR PName .)
    LE              reduce using rule 73 (PName -> STAR PName .)
    EQ              reduce using rule 73 (PName -> STAR PName .)
    NE              reduce using rule 73 (PName -> STAR PName .)
    COMMA           reduce using rule 73 (PName -> STAR PName .)


state 103

    (74) PName -> STAR NAME .

    SEMICOLON       reduce using rule 74 (PName -> STAR NAME .)
    PLUS            reduce using rule 74 (PName -> STAR NAME .)
    MINUS           reduce using rule 74 (PName -> STAR NAME .)
    STAR            reduce using rule 74 (PName -> STAR NAME .)
    DIVIDE          reduce using rule 74 (PName -> STAR NAME .)
    RPAREN          reduce using rule 74 (PName -> STAR NAME .)
    AND             reduce using rule 74 (PName -> STAR NAME .)
    OR              reduce using rule 74 (PName -> STAR NAME .)
    GT              reduce using rule 74 (PName -> STAR NAME .)
    LT              reduce using rule 74 (PName -> STAR NAME .)
    GE              reduce using rule 74 (PName -> STAR NAME .)
    LE              reduce using rule 74 (PName -> STAR NAME .)
    EQ              reduce using rule 74 (PName -> STAR NAME .)
    NE              reduce using rule 74 (PName -> STAR NAME .)
    COMMA           reduce using rule 74 (PName -> STAR NAME .)


state 104

    (75) PName -> AMPERSAND NAME .

    SEMICOLON       reduce using rule 75 (PName -> AMPERSAND NAME .)
    PLUS            reduce using rule 75 (PName -> AMPERSAND NAME .)
    MINUS           reduce using rule 75 (PName -> AMPERSAND NAME .)
    STAR            reduce using rule 75 (PName -> AMPERSAND NAME .)
    DIVIDE          reduce using rule 75 (PName -> AMPERSAND NAME .)
    RPAREN          reduce using rule 75 (PName -> AMPERSAND NAME .)
    AND             reduce using rule 75 (PName -> AMPERSAND NAME .)
    OR              reduce using rule 75 (PName -> AMPERSAND NAME .)
    GT              reduce using rule 75 (PName -> AMPERSAND NAME .)
    LT              reduce using rule 75 (PName -> AMPERSAND NAME .)
    GE              reduce using rule 75 (PName -> AMPERSAND NAME .)
    LE              reduce using rule 75 (PName -> AMPERSAND NAME .)
    EQ              reduce using rule 75 (PName -> AMPERSAND NAME .)
    NE              reduce using rule 75 (PName -> AMPERSAND NAME .)
    COMMA           reduce using rule 75 (PName -> AMPERSAND NAME .)


state 105

    (68) R2 -> MINUS R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    PLUS            reduce using rule 68 (R2 -> MINUS R2 .)
    MINUS           reduce using rule 68 (R2 -> MINUS R2 .)
    DIVIDE          reduce using rule 68 (R2 -> MINUS R2 .)
    SEMICOLON       reduce using rule 68 (R2 -> MINUS R2 .)
    GT              reduce using rule 68 (R2 -> MINUS R2 .)
    LT              reduce using rule 68 (R2 -> MINUS R2 .)
    GE              reduce using rule 68 (R2 -> MINUS R2 .)
    LE              reduce using rule 68 (R2 -> MINUS R2 .)
    EQ              reduce using rule 68 (R2 -> MINUS R2 .)
    NE              reduce using rule 68 (R2 -> MINUS R2 .)
    COMMA           reduce using rule 68 (R2 -> MINUS R2 .)
    RPAREN          reduce using rule 68 (R2 -> MINUS R2 .)
    AND             reduce using rule 68 (R2 -> MINUS R2 .)
    OR              reduce using rule 68 (R2 -> MINUS R2 .)
    STAR            shift and go to state 107

  ! STAR            [ reduce using rule 68 (R2 -> MINUS R2 .) ]
  ! PLUS            [ shift and go to state 111 ]
  ! MINUS           [ shift and go to state 109 ]
  ! DIVIDE          [ shift and go to state 110 ]


state 106

    (67) R2 -> LPAREN R2 . RPAREN
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    RPAREN          shift and go to state 137
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 107

    (65) R2 -> R2 STAR . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 138

state 108

    (25) return_stmt -> RETURN R2 SEMICOLON .

    RCURLY          reduce using rule 25 (return_stmt -> RETURN R2 SEMICOLON .)


state 109

    (64) R2 -> R2 MINUS . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 139

state 110

    (66) R2 -> R2 DIVIDE . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 140

state 111

    (63) R2 -> R2 PLUS . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 141

state 112

    (21) function_body -> LCURLY stmt_list return_stmt RCURLY .

    VOID            reduce using rule 21 (function_body -> LCURLY stmt_list return_stmt RCURLY .)
    INT             reduce using rule 21 (function_body -> LCURLY stmt_list return_stmt RCURLY .)
    FLOAT           reduce using rule 21 (function_body -> LCURLY stmt_list return_stmt RCURLY .)
    $end            reduce using rule 21 (function_body -> LCURLY stmt_list return_stmt RCURLY .)


state 113

    (85) matched_loop -> WHILE LPAREN condition . RPAREN matched_stmt
    (86) matched_loop -> WHILE LPAREN condition . RPAREN body
    (87) matched_loop -> WHILE LPAREN condition . RPAREN SEMICOLON
    (88) unmatched_loop -> WHILE LPAREN condition . RPAREN unmatched_stmt
    (89) condition -> condition . AND condition
    (90) condition -> condition . OR condition

    RPAREN          shift and go to state 142
    AND             shift and go to state 125
    OR              shift and go to state 123


state 114

    (39) assign -> L1 EQUALS R1 . SEMICOLON
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    SEMICOLON       shift and go to state 144
    PLUS            shift and go to state 146
    MINUS           shift and go to state 145
    STAR            shift and go to state 143
    DIVIDE          shift and go to state 147


state 115

    (57) R1 -> function_call .

    PLUS            reduce using rule 57 (R1 -> function_call .)
    MINUS           reduce using rule 57 (R1 -> function_call .)
    STAR            reduce using rule 57 (R1 -> function_call .)
    DIVIDE          reduce using rule 57 (R1 -> function_call .)
    SEMICOLON       reduce using rule 57 (R1 -> function_call .)
    RPAREN          reduce using rule 57 (R1 -> function_call .)


state 116

    (58) R1 -> NAME .
    (76) function_call -> NAME . LPAREN arg_list RPAREN
    (77) function_call -> NAME . LPAREN RPAREN

    PLUS            reduce using rule 58 (R1 -> NAME .)
    MINUS           reduce using rule 58 (R1 -> NAME .)
    STAR            reduce using rule 58 (R1 -> NAME .)
    DIVIDE          reduce using rule 58 (R1 -> NAME .)
    SEMICOLON       reduce using rule 58 (R1 -> NAME .)
    RPAREN          reduce using rule 58 (R1 -> NAME .)
    LPAREN          shift and go to state 78


state 117

    (46) R1 -> ALLNUM . PLUS R1
    (47) R1 -> ALLNUM . MINUS R1
    (48) R1 -> ALLNUM . STAR R1
    (49) R1 -> ALLNUM . DIVIDE R1

    PLUS            shift and go to state 151
    MINUS           shift and go to state 149
    STAR            shift and go to state 148
    DIVIDE          shift and go to state 150


state 118

    (59) ALLNUM -> NUMBER .

    PLUS            reduce using rule 59 (ALLNUM -> NUMBER .)
    MINUS           reduce using rule 59 (ALLNUM -> NUMBER .)
    STAR            reduce using rule 59 (ALLNUM -> NUMBER .)
    DIVIDE          reduce using rule 59 (ALLNUM -> NUMBER .)
    SEMICOLON       reduce using rule 59 (ALLNUM -> NUMBER .)
    RPAREN          reduce using rule 59 (ALLNUM -> NUMBER .)


state 119

    (55) R1 -> MINUS . R1
    (60) ALLNUM -> MINUS . ALLNUM
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 120
    MINUS           shift and go to state 119
    NAME            shift and go to state 116
    NUMBER          shift and go to state 118
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 153
    PName                          shift and go to state 121
    R1                             shift and go to state 152
    function_call                  shift and go to state 115

state 120

    (54) R1 -> LPAREN . R1 RPAREN
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 120
    MINUS           shift and go to state 119
    NAME            shift and go to state 116
    NUMBER          shift and go to state 118
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 117
    PName                          shift and go to state 121
    R1                             shift and go to state 154
    function_call                  shift and go to state 115

state 121

    (56) R1 -> PName .

    PLUS            reduce using rule 56 (R1 -> PName .)
    MINUS           reduce using rule 56 (R1 -> PName .)
    STAR            reduce using rule 56 (R1 -> PName .)
    DIVIDE          reduce using rule 56 (R1 -> PName .)
    SEMICOLON       reduce using rule 56 (R1 -> PName .)
    RPAREN          reduce using rule 56 (R1 -> PName .)


state 122

    (40) assign -> L2 EQUALS R2 SEMICOLON .

    IF              reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)
    WHILE           reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)
    NAME            reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)
    STAR            reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)
    INT             reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)
    FLOAT           reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)
    RCURLY          reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)
    RETURN          reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)
    ELSE            reduce using rule 40 (assign -> L2 EQUALS R2 SEMICOLON .)


state 123

    (90) condition -> condition OR . condition
    (89) condition -> . condition AND condition
    (90) condition -> . condition OR condition
    (91) condition -> . LPAREN condition RPAREN
    (92) condition -> . NOT condition
    (93) condition -> . R2 GT R2
    (94) condition -> . R2 LT R2
    (95) condition -> . R2 GE R2
    (96) condition -> . R2 LE R2
    (97) condition -> . R2 EQ R2
    (98) condition -> . R2 NE R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 97
    NOT             shift and go to state 98
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    condition                      shift and go to state 155
    PName                          shift and go to state 88
    R2                             shift and go to state 96

state 124

    (99) matched_decision -> IF LPAREN condition RPAREN . matched_stmt ELSE matched_stmt
    (100) matched_decision -> IF LPAREN condition RPAREN . matched_stmt ELSE body
    (101) matched_decision -> IF LPAREN condition RPAREN . body ELSE matched_stmt
    (102) matched_decision -> IF LPAREN condition RPAREN . body ELSE body
    (103) matched_decision -> IF LPAREN condition RPAREN . matched_stmt ELSE SEMICOLON
    (104) matched_decision -> IF LPAREN condition RPAREN . body ELSE SEMICOLON
    (105) matched_decision -> IF LPAREN condition RPAREN . SEMICOLON ELSE matched_stmt
    (106) matched_decision -> IF LPAREN condition RPAREN . SEMICOLON ELSE body
    (107) matched_decision -> IF LPAREN condition RPAREN . SEMICOLON ELSE SEMICOLON
    (108) unmatched_decision -> IF LPAREN condition RPAREN . stmt
    (109) unmatched_decision -> IF LPAREN condition RPAREN . body
    (110) unmatched_decision -> IF LPAREN condition RPAREN . SEMICOLON
    (111) unmatched_decision -> IF LPAREN condition RPAREN . matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> IF LPAREN condition RPAREN . body ELSE unmatched_stmt
    (113) unmatched_decision -> IF LPAREN condition RPAREN . SEMICOLON ELSE unmatched_stmt
    (32) matched_stmt -> . assign
    (33) matched_stmt -> . declaration
    (34) matched_stmt -> . matched_decision
    (35) matched_stmt -> . matched_loop
    (36) matched_stmt -> . function_call SEMICOLON
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY
    (30) stmt -> . matched_stmt
    (31) stmt -> . unmatched_stmt
    (39) assign -> . L1 EQUALS R1 SEMICOLON
    (40) assign -> . L2 EQUALS R2 SEMICOLON
    (80) declaration -> . TYPE varlist SEMICOLON
    (99) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> . IF LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> . IF LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> . IF LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (85) matched_loop -> . WHILE LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> . WHILE LPAREN condition RPAREN body
    (87) matched_loop -> . WHILE LPAREN condition RPAREN SEMICOLON
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN
    (37) unmatched_stmt -> . unmatched_decision
    (38) unmatched_stmt -> . unmatched_loop
    (41) L1 -> . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT
    (108) unmatched_decision -> . IF LPAREN condition RPAREN stmt
    (109) unmatched_decision -> . IF LPAREN condition RPAREN body
    (110) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> . IF LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt
    (88) unmatched_loop -> . WHILE LPAREN condition RPAREN unmatched_stmt

    SEMICOLON       shift and go to state 159
    LCURLY          shift and go to state 157
    IF              shift and go to state 55
    WHILE           shift and go to state 66
    NAME            shift and go to state 59
    STAR            shift and go to state 52
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    matched_stmt                   shift and go to state 158
    L2                             shift and go to state 49
    TYPE                           shift and go to state 56
    function_call                  shift and go to state 58
    declaration                    shift and go to state 50
    matched_loop                   shift and go to state 62
    body                           shift and go to state 156
    matched_decision               shift and go to state 53
    unmatched_decision             shift and go to state 51
    unmatched_loop                 shift and go to state 63
    stmt                           shift and go to state 160
    assign                         shift and go to state 54
    unmatched_stmt                 shift and go to state 67
    L1                             shift and go to state 68

state 125

    (89) condition -> condition AND . condition
    (89) condition -> . condition AND condition
    (90) condition -> . condition OR condition
    (91) condition -> . LPAREN condition RPAREN
    (92) condition -> . NOT condition
    (93) condition -> . R2 GT R2
    (94) condition -> . R2 LT R2
    (95) condition -> . R2 GE R2
    (96) condition -> . R2 LE R2
    (97) condition -> . R2 EQ R2
    (98) condition -> . R2 NE R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 97
    NOT             shift and go to state 98
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    condition                      shift and go to state 161
    PName                          shift and go to state 88
    R2                             shift and go to state 96

state 126

    (93) condition -> R2 GT . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 162

state 127

    (95) condition -> R2 GE . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 163

state 128

    (98) condition -> R2 NE . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 164

state 129

    (97) condition -> R2 EQ . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 165

state 130

    (96) condition -> R2 LE . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 166

state 131

    (94) condition -> R2 LT . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    R2                             shift and go to state 167

state 132

    (91) condition -> LPAREN condition . RPAREN
    (89) condition -> condition . AND condition
    (90) condition -> condition . OR condition

    RPAREN          shift and go to state 168
    AND             shift and go to state 125
    OR              shift and go to state 123


state 133

    (67) R2 -> LPAREN R2 . RPAREN
    (93) condition -> R2 . GT R2
    (94) condition -> R2 . LT R2
    (95) condition -> R2 . GE R2
    (96) condition -> R2 . LE R2
    (97) condition -> R2 . EQ R2
    (98) condition -> R2 . NE R2
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    RPAREN          shift and go to state 137
    GT              shift and go to state 126
    LT              shift and go to state 131
    GE              shift and go to state 127
    LE              shift and go to state 130
    EQ              shift and go to state 129
    NE              shift and go to state 128
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 134

    (92) condition -> NOT condition .
    (89) condition -> condition . AND condition
    (90) condition -> condition . OR condition

    RPAREN          reduce using rule 92 (condition -> NOT condition .)
    AND             reduce using rule 92 (condition -> NOT condition .)
    OR              reduce using rule 92 (condition -> NOT condition .)

  ! AND             [ shift and go to state 125 ]
  ! OR              [ shift and go to state 123 ]


state 135

    (76) function_call -> NAME LPAREN arg_list RPAREN .

    PLUS            reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    STAR            reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    DIVIDE          reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    SEMICOLON       reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    GT              reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    LT              reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    GE              reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    LE              reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    EQ              reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    NE              reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    AND             reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)
    OR              reduce using rule 76 (function_call -> NAME LPAREN arg_list RPAREN .)


state 136

    (78) arg_list -> R2 COMMA . arg_list
    (78) arg_list -> . R2 COMMA arg_list
    (79) arg_list -> . R2
    (63) R2 -> . R2 PLUS R2
    (64) R2 -> . R2 MINUS R2
    (65) R2 -> . R2 STAR R2
    (66) R2 -> . R2 DIVIDE R2
    (67) R2 -> . LPAREN R2 RPAREN
    (68) R2 -> . MINUS R2
    (69) R2 -> . PName
    (70) R2 -> . function_call
    (71) R2 -> . NAME
    (72) R2 -> . NUMBER
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 85
    NAME            shift and go to state 81
    NUMBER          shift and go to state 82
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    function_call                  shift and go to state 80
    PName                          shift and go to state 88
    arg_list                       shift and go to state 169
    R2                             shift and go to state 100

state 137

    (67) R2 -> LPAREN R2 RPAREN .

    PLUS            reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    MINUS           reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    STAR            reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    DIVIDE          reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    SEMICOLON       reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    GT              reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    LT              reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    GE              reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    LE              reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    EQ              reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    NE              reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    COMMA           reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    RPAREN          reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    AND             reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)
    OR              reduce using rule 67 (R2 -> LPAREN R2 RPAREN .)


state 138

    (65) R2 -> R2 STAR R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    PLUS            reduce using rule 65 (R2 -> R2 STAR R2 .)
    MINUS           reduce using rule 65 (R2 -> R2 STAR R2 .)
    DIVIDE          reduce using rule 65 (R2 -> R2 STAR R2 .)
    SEMICOLON       reduce using rule 65 (R2 -> R2 STAR R2 .)
    GT              reduce using rule 65 (R2 -> R2 STAR R2 .)
    LT              reduce using rule 65 (R2 -> R2 STAR R2 .)
    GE              reduce using rule 65 (R2 -> R2 STAR R2 .)
    LE              reduce using rule 65 (R2 -> R2 STAR R2 .)
    EQ              reduce using rule 65 (R2 -> R2 STAR R2 .)
    NE              reduce using rule 65 (R2 -> R2 STAR R2 .)
    COMMA           reduce using rule 65 (R2 -> R2 STAR R2 .)
    RPAREN          reduce using rule 65 (R2 -> R2 STAR R2 .)
    AND             reduce using rule 65 (R2 -> R2 STAR R2 .)
    OR              reduce using rule 65 (R2 -> R2 STAR R2 .)
    STAR            shift and go to state 107

  ! STAR            [ reduce using rule 65 (R2 -> R2 STAR R2 .) ]
  ! PLUS            [ shift and go to state 111 ]
  ! MINUS           [ shift and go to state 109 ]
  ! DIVIDE          [ shift and go to state 110 ]


state 139

    (64) R2 -> R2 MINUS R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    PLUS            reduce using rule 64 (R2 -> R2 MINUS R2 .)
    MINUS           reduce using rule 64 (R2 -> R2 MINUS R2 .)
    SEMICOLON       reduce using rule 64 (R2 -> R2 MINUS R2 .)
    GT              reduce using rule 64 (R2 -> R2 MINUS R2 .)
    LT              reduce using rule 64 (R2 -> R2 MINUS R2 .)
    GE              reduce using rule 64 (R2 -> R2 MINUS R2 .)
    LE              reduce using rule 64 (R2 -> R2 MINUS R2 .)
    EQ              reduce using rule 64 (R2 -> R2 MINUS R2 .)
    NE              reduce using rule 64 (R2 -> R2 MINUS R2 .)
    COMMA           reduce using rule 64 (R2 -> R2 MINUS R2 .)
    RPAREN          reduce using rule 64 (R2 -> R2 MINUS R2 .)
    AND             reduce using rule 64 (R2 -> R2 MINUS R2 .)
    OR              reduce using rule 64 (R2 -> R2 MINUS R2 .)
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110

  ! STAR            [ reduce using rule 64 (R2 -> R2 MINUS R2 .) ]
  ! DIVIDE          [ reduce using rule 64 (R2 -> R2 MINUS R2 .) ]
  ! PLUS            [ shift and go to state 111 ]
  ! MINUS           [ shift and go to state 109 ]


state 140

    (66) R2 -> R2 DIVIDE R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    PLUS            reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    MINUS           reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    DIVIDE          reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    SEMICOLON       reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    GT              reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    LT              reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    GE              reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    LE              reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    EQ              reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    NE              reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    COMMA           reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    RPAREN          reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    AND             reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    OR              reduce using rule 66 (R2 -> R2 DIVIDE R2 .)
    STAR            shift and go to state 107

  ! STAR            [ reduce using rule 66 (R2 -> R2 DIVIDE R2 .) ]
  ! PLUS            [ shift and go to state 111 ]
  ! MINUS           [ shift and go to state 109 ]
  ! DIVIDE          [ shift and go to state 110 ]


state 141

    (63) R2 -> R2 PLUS R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    PLUS            reduce using rule 63 (R2 -> R2 PLUS R2 .)
    MINUS           reduce using rule 63 (R2 -> R2 PLUS R2 .)
    SEMICOLON       reduce using rule 63 (R2 -> R2 PLUS R2 .)
    GT              reduce using rule 63 (R2 -> R2 PLUS R2 .)
    LT              reduce using rule 63 (R2 -> R2 PLUS R2 .)
    GE              reduce using rule 63 (R2 -> R2 PLUS R2 .)
    LE              reduce using rule 63 (R2 -> R2 PLUS R2 .)
    EQ              reduce using rule 63 (R2 -> R2 PLUS R2 .)
    NE              reduce using rule 63 (R2 -> R2 PLUS R2 .)
    COMMA           reduce using rule 63 (R2 -> R2 PLUS R2 .)
    RPAREN          reduce using rule 63 (R2 -> R2 PLUS R2 .)
    AND             reduce using rule 63 (R2 -> R2 PLUS R2 .)
    OR              reduce using rule 63 (R2 -> R2 PLUS R2 .)
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110

  ! STAR            [ reduce using rule 63 (R2 -> R2 PLUS R2 .) ]
  ! DIVIDE          [ reduce using rule 63 (R2 -> R2 PLUS R2 .) ]
  ! PLUS            [ shift and go to state 111 ]
  ! MINUS           [ shift and go to state 109 ]


state 142

    (85) matched_loop -> WHILE LPAREN condition RPAREN . matched_stmt
    (86) matched_loop -> WHILE LPAREN condition RPAREN . body
    (87) matched_loop -> WHILE LPAREN condition RPAREN . SEMICOLON
    (88) unmatched_loop -> WHILE LPAREN condition RPAREN . unmatched_stmt
    (32) matched_stmt -> . assign
    (33) matched_stmt -> . declaration
    (34) matched_stmt -> . matched_decision
    (35) matched_stmt -> . matched_loop
    (36) matched_stmt -> . function_call SEMICOLON
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY
    (37) unmatched_stmt -> . unmatched_decision
    (38) unmatched_stmt -> . unmatched_loop
    (39) assign -> . L1 EQUALS R1 SEMICOLON
    (40) assign -> . L2 EQUALS R2 SEMICOLON
    (80) declaration -> . TYPE varlist SEMICOLON
    (99) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> . IF LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> . IF LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> . IF LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (85) matched_loop -> . WHILE LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> . WHILE LPAREN condition RPAREN body
    (87) matched_loop -> . WHILE LPAREN condition RPAREN SEMICOLON
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN
    (108) unmatched_decision -> . IF LPAREN condition RPAREN stmt
    (109) unmatched_decision -> . IF LPAREN condition RPAREN body
    (110) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> . IF LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt
    (88) unmatched_loop -> . WHILE LPAREN condition RPAREN unmatched_stmt
    (41) L1 -> . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    SEMICOLON       shift and go to state 172
    LCURLY          shift and go to state 157
    IF              shift and go to state 55
    WHILE           shift and go to state 66
    NAME            shift and go to state 59
    STAR            shift and go to state 52
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    unmatched_decision             shift and go to state 51
    L2                             shift and go to state 49
    TYPE                           shift and go to state 56
    function_call                  shift and go to state 58
    declaration                    shift and go to state 50
    matched_loop                   shift and go to state 62
    assign                         shift and go to state 54
    body                           shift and go to state 170
    matched_decision               shift and go to state 53
    unmatched_loop                 shift and go to state 63
    matched_stmt                   shift and go to state 171
    unmatched_stmt                 shift and go to state 173
    L1                             shift and go to state 68

state 143

    (44) R1 -> R1 STAR . ALLNUM
    (52) R1 -> R1 STAR . R1
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    NUMBER          shift and go to state 118
    MINUS           shift and go to state 176
    LPAREN          shift and go to state 120
    NAME            shift and go to state 116
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 175
    PName                          shift and go to state 121
    R1                             shift and go to state 174
    function_call                  shift and go to state 115

state 144

    (39) assign -> L1 EQUALS R1 SEMICOLON .

    IF              reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)
    WHILE           reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)
    NAME            reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)
    STAR            reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)
    INT             reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)
    FLOAT           reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)
    RCURLY          reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)
    RETURN          reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)
    ELSE            reduce using rule 39 (assign -> L1 EQUALS R1 SEMICOLON .)


state 145

    (43) R1 -> R1 MINUS . ALLNUM
    (51) R1 -> R1 MINUS . R1
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    NUMBER          shift and go to state 118
    MINUS           shift and go to state 176
    LPAREN          shift and go to state 120
    NAME            shift and go to state 116
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 178
    PName                          shift and go to state 121
    R1                             shift and go to state 177
    function_call                  shift and go to state 115

state 146

    (42) R1 -> R1 PLUS . ALLNUM
    (50) R1 -> R1 PLUS . R1
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    NUMBER          shift and go to state 118
    MINUS           shift and go to state 176
    LPAREN          shift and go to state 120
    NAME            shift and go to state 116
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 180
    PName                          shift and go to state 121
    R1                             shift and go to state 179
    function_call                  shift and go to state 115

state 147

    (45) R1 -> R1 DIVIDE . ALLNUM
    (53) R1 -> R1 DIVIDE . R1
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    NUMBER          shift and go to state 118
    MINUS           shift and go to state 176
    LPAREN          shift and go to state 120
    NAME            shift and go to state 116
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 182
    PName                          shift and go to state 121
    R1                             shift and go to state 181
    function_call                  shift and go to state 115

state 148

    (48) R1 -> ALLNUM STAR . R1
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 120
    MINUS           shift and go to state 119
    NAME            shift and go to state 116
    NUMBER          shift and go to state 118
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 117
    PName                          shift and go to state 121
    R1                             shift and go to state 183
    function_call                  shift and go to state 115

state 149

    (47) R1 -> ALLNUM MINUS . R1
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 120
    MINUS           shift and go to state 119
    NAME            shift and go to state 116
    NUMBER          shift and go to state 118
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 117
    PName                          shift and go to state 121
    R1                             shift and go to state 184
    function_call                  shift and go to state 115

state 150

    (49) R1 -> ALLNUM DIVIDE . R1
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 120
    MINUS           shift and go to state 119
    NAME            shift and go to state 116
    NUMBER          shift and go to state 118
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 117
    PName                          shift and go to state 121
    R1                             shift and go to state 185
    function_call                  shift and go to state 115

state 151

    (46) R1 -> ALLNUM PLUS . R1
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    LPAREN          shift and go to state 120
    MINUS           shift and go to state 119
    NAME            shift and go to state 116
    NUMBER          shift and go to state 118
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 117
    PName                          shift and go to state 121
    R1                             shift and go to state 186
    function_call                  shift and go to state 115

state 152

    (55) R1 -> MINUS R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 55 (R1 -> MINUS R1 .)
    MINUS           reduce using rule 55 (R1 -> MINUS R1 .)
    DIVIDE          reduce using rule 55 (R1 -> MINUS R1 .)
    SEMICOLON       reduce using rule 55 (R1 -> MINUS R1 .)
    RPAREN          reduce using rule 55 (R1 -> MINUS R1 .)
    STAR            shift and go to state 143

  ! STAR            [ reduce using rule 55 (R1 -> MINUS R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]
  ! DIVIDE          [ shift and go to state 147 ]


state 153

    (60) ALLNUM -> MINUS ALLNUM .
    (46) R1 -> ALLNUM . PLUS R1
    (47) R1 -> ALLNUM . MINUS R1
    (48) R1 -> ALLNUM . STAR R1
    (49) R1 -> ALLNUM . DIVIDE R1

    PLUS            reduce using rule 60 (ALLNUM -> MINUS ALLNUM .)
    MINUS           reduce using rule 60 (ALLNUM -> MINUS ALLNUM .)
    DIVIDE          reduce using rule 60 (ALLNUM -> MINUS ALLNUM .)
    SEMICOLON       reduce using rule 60 (ALLNUM -> MINUS ALLNUM .)
    RPAREN          reduce using rule 60 (ALLNUM -> MINUS ALLNUM .)
    STAR            shift and go to state 148

  ! STAR            [ reduce using rule 60 (ALLNUM -> MINUS ALLNUM .) ]
  ! PLUS            [ shift and go to state 151 ]
  ! MINUS           [ shift and go to state 149 ]
  ! DIVIDE          [ shift and go to state 150 ]


state 154

    (54) R1 -> LPAREN R1 . RPAREN
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    RPAREN          shift and go to state 187
    PLUS            shift and go to state 146
    MINUS           shift and go to state 145
    STAR            shift and go to state 143
    DIVIDE          shift and go to state 147


state 155

    (90) condition -> condition OR condition .
    (89) condition -> condition . AND condition
    (90) condition -> condition . OR condition

    RPAREN          reduce using rule 90 (condition -> condition OR condition .)
    OR              reduce using rule 90 (condition -> condition OR condition .)
    AND             shift and go to state 125

  ! AND             [ reduce using rule 90 (condition -> condition OR condition .) ]
  ! OR              [ shift and go to state 123 ]


state 156

    (101) matched_decision -> IF LPAREN condition RPAREN body . ELSE matched_stmt
    (102) matched_decision -> IF LPAREN condition RPAREN body . ELSE body
    (104) matched_decision -> IF LPAREN condition RPAREN body . ELSE SEMICOLON
    (109) unmatched_decision -> IF LPAREN condition RPAREN body .
    (112) unmatched_decision -> IF LPAREN condition RPAREN body . ELSE unmatched_stmt

    ELSE            shift and go to state 188
    IF              reduce using rule 109 (unmatched_decision -> IF LPAREN condition RPAREN body .)
    WHILE           reduce using rule 109 (unmatched_decision -> IF LPAREN condition RPAREN body .)
    NAME            reduce using rule 109 (unmatched_decision -> IF LPAREN condition RPAREN body .)
    STAR            reduce using rule 109 (unmatched_decision -> IF LPAREN condition RPAREN body .)
    INT             reduce using rule 109 (unmatched_decision -> IF LPAREN condition RPAREN body .)
    FLOAT           reduce using rule 109 (unmatched_decision -> IF LPAREN condition RPAREN body .)
    RCURLY          reduce using rule 109 (unmatched_decision -> IF LPAREN condition RPAREN body .)
    RETURN          reduce using rule 109 (unmatched_decision -> IF LPAREN condition RPAREN body .)


state 157

    (26) body -> LCURLY . stmt_list RCURLY
    (27) body -> LCURLY . RCURLY
    (28) stmt_list -> . stmt stmt_list
    (29) stmt_list -> . stmt
    (30) stmt -> . matched_stmt
    (31) stmt -> . unmatched_stmt
    (32) matched_stmt -> . assign
    (33) matched_stmt -> . declaration
    (34) matched_stmt -> . matched_decision
    (35) matched_stmt -> . matched_loop
    (36) matched_stmt -> . function_call SEMICOLON
    (37) unmatched_stmt -> . unmatched_decision
    (38) unmatched_stmt -> . unmatched_loop
    (39) assign -> . L1 EQUALS R1 SEMICOLON
    (40) assign -> . L2 EQUALS R2 SEMICOLON
    (80) declaration -> . TYPE varlist SEMICOLON
    (99) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> . IF LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> . IF LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> . IF LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (85) matched_loop -> . WHILE LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> . WHILE LPAREN condition RPAREN body
    (87) matched_loop -> . WHILE LPAREN condition RPAREN SEMICOLON
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN
    (108) unmatched_decision -> . IF LPAREN condition RPAREN stmt
    (109) unmatched_decision -> . IF LPAREN condition RPAREN body
    (110) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> . IF LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt
    (88) unmatched_loop -> . WHILE LPAREN condition RPAREN unmatched_stmt
    (41) L1 -> . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    RCURLY          shift and go to state 48
    IF              shift and go to state 55
    WHILE           shift and go to state 66
    NAME            shift and go to state 59
    STAR            shift and go to state 52
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    matched_stmt                   shift and go to state 60
    L2                             shift and go to state 49
    TYPE                           shift and go to state 56
    function_call                  shift and go to state 58
    declaration                    shift and go to state 50
    unmatched_decision             shift and go to state 51
    matched_loop                   shift and go to state 62
    unmatched_loop                 shift and go to state 63
    matched_decision               shift and go to state 53
    stmt_list                      shift and go to state 189
    stmt                           shift and go to state 65
    assign                         shift and go to state 54
    unmatched_stmt                 shift and go to state 67
    L1                             shift and go to state 68

state 158

    (99) matched_decision -> IF LPAREN condition RPAREN matched_stmt . ELSE matched_stmt
    (100) matched_decision -> IF LPAREN condition RPAREN matched_stmt . ELSE body
    (103) matched_decision -> IF LPAREN condition RPAREN matched_stmt . ELSE SEMICOLON
    (111) unmatched_decision -> IF LPAREN condition RPAREN matched_stmt . ELSE unmatched_stmt
    (30) stmt -> matched_stmt .

    ELSE            shift and go to state 190
    IF              reduce using rule 30 (stmt -> matched_stmt .)
    WHILE           reduce using rule 30 (stmt -> matched_stmt .)
    NAME            reduce using rule 30 (stmt -> matched_stmt .)
    STAR            reduce using rule 30 (stmt -> matched_stmt .)
    INT             reduce using rule 30 (stmt -> matched_stmt .)
    FLOAT           reduce using rule 30 (stmt -> matched_stmt .)
    RCURLY          reduce using rule 30 (stmt -> matched_stmt .)
    RETURN          reduce using rule 30 (stmt -> matched_stmt .)


state 159

    (105) matched_decision -> IF LPAREN condition RPAREN SEMICOLON . ELSE matched_stmt
    (106) matched_decision -> IF LPAREN condition RPAREN SEMICOLON . ELSE body
    (107) matched_decision -> IF LPAREN condition RPAREN SEMICOLON . ELSE SEMICOLON
    (110) unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .
    (113) unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON . ELSE unmatched_stmt

    ELSE            shift and go to state 191
    IF              reduce using rule 110 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .)
    WHILE           reduce using rule 110 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .)
    NAME            reduce using rule 110 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .)
    STAR            reduce using rule 110 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .)
    INT             reduce using rule 110 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .)
    FLOAT           reduce using rule 110 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .)
    RCURLY          reduce using rule 110 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .)
    RETURN          reduce using rule 110 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON .)


state 160

    (108) unmatched_decision -> IF LPAREN condition RPAREN stmt .

    IF              reduce using rule 108 (unmatched_decision -> IF LPAREN condition RPAREN stmt .)
    WHILE           reduce using rule 108 (unmatched_decision -> IF LPAREN condition RPAREN stmt .)
    NAME            reduce using rule 108 (unmatched_decision -> IF LPAREN condition RPAREN stmt .)
    STAR            reduce using rule 108 (unmatched_decision -> IF LPAREN condition RPAREN stmt .)
    INT             reduce using rule 108 (unmatched_decision -> IF LPAREN condition RPAREN stmt .)
    FLOAT           reduce using rule 108 (unmatched_decision -> IF LPAREN condition RPAREN stmt .)
    RCURLY          reduce using rule 108 (unmatched_decision -> IF LPAREN condition RPAREN stmt .)
    RETURN          reduce using rule 108 (unmatched_decision -> IF LPAREN condition RPAREN stmt .)


state 161

    (89) condition -> condition AND condition .
    (89) condition -> condition . AND condition
    (90) condition -> condition . OR condition

    RPAREN          reduce using rule 89 (condition -> condition AND condition .)
    AND             reduce using rule 89 (condition -> condition AND condition .)
    OR              reduce using rule 89 (condition -> condition AND condition .)

  ! AND             [ shift and go to state 125 ]
  ! OR              [ shift and go to state 123 ]


state 162

    (93) condition -> R2 GT R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    RPAREN          reduce using rule 93 (condition -> R2 GT R2 .)
    AND             reduce using rule 93 (condition -> R2 GT R2 .)
    OR              reduce using rule 93 (condition -> R2 GT R2 .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 163

    (95) condition -> R2 GE R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    RPAREN          reduce using rule 95 (condition -> R2 GE R2 .)
    AND             reduce using rule 95 (condition -> R2 GE R2 .)
    OR              reduce using rule 95 (condition -> R2 GE R2 .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 164

    (98) condition -> R2 NE R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    RPAREN          reduce using rule 98 (condition -> R2 NE R2 .)
    AND             reduce using rule 98 (condition -> R2 NE R2 .)
    OR              reduce using rule 98 (condition -> R2 NE R2 .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 165

    (97) condition -> R2 EQ R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    RPAREN          reduce using rule 97 (condition -> R2 EQ R2 .)
    AND             reduce using rule 97 (condition -> R2 EQ R2 .)
    OR              reduce using rule 97 (condition -> R2 EQ R2 .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 166

    (96) condition -> R2 LE R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    RPAREN          reduce using rule 96 (condition -> R2 LE R2 .)
    AND             reduce using rule 96 (condition -> R2 LE R2 .)
    OR              reduce using rule 96 (condition -> R2 LE R2 .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 167

    (94) condition -> R2 LT R2 .
    (63) R2 -> R2 . PLUS R2
    (64) R2 -> R2 . MINUS R2
    (65) R2 -> R2 . STAR R2
    (66) R2 -> R2 . DIVIDE R2

    RPAREN          reduce using rule 94 (condition -> R2 LT R2 .)
    AND             reduce using rule 94 (condition -> R2 LT R2 .)
    OR              reduce using rule 94 (condition -> R2 LT R2 .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 109
    STAR            shift and go to state 107
    DIVIDE          shift and go to state 110


state 168

    (91) condition -> LPAREN condition RPAREN .

    RPAREN          reduce using rule 91 (condition -> LPAREN condition RPAREN .)
    AND             reduce using rule 91 (condition -> LPAREN condition RPAREN .)
    OR              reduce using rule 91 (condition -> LPAREN condition RPAREN .)


state 169

    (78) arg_list -> R2 COMMA arg_list .

    RPAREN          reduce using rule 78 (arg_list -> R2 COMMA arg_list .)


state 170

    (86) matched_loop -> WHILE LPAREN condition RPAREN body .

    IF              reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)
    WHILE           reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)
    NAME            reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)
    STAR            reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)
    INT             reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)
    FLOAT           reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)
    RCURLY          reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)
    RETURN          reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)
    ELSE            reduce using rule 86 (matched_loop -> WHILE LPAREN condition RPAREN body .)


state 171

    (85) matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .

    IF              reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)
    WHILE           reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)
    NAME            reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)
    STAR            reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)
    INT             reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)
    FLOAT           reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)
    RCURLY          reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)
    RETURN          reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)
    ELSE            reduce using rule 85 (matched_loop -> WHILE LPAREN condition RPAREN matched_stmt .)


state 172

    (87) matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .

    IF              reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)
    WHILE           reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)
    NAME            reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)
    STAR            reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)
    INT             reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)
    FLOAT           reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)
    RCURLY          reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)
    RETURN          reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)
    ELSE            reduce using rule 87 (matched_loop -> WHILE LPAREN condition RPAREN SEMICOLON .)


state 173

    (88) unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .

    IF              reduce using rule 88 (unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .)
    WHILE           reduce using rule 88 (unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .)
    NAME            reduce using rule 88 (unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .)
    STAR            reduce using rule 88 (unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .)
    INT             reduce using rule 88 (unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .)
    FLOAT           reduce using rule 88 (unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .)
    RCURLY          reduce using rule 88 (unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .)
    RETURN          reduce using rule 88 (unmatched_loop -> WHILE LPAREN condition RPAREN unmatched_stmt .)


state 174

    (52) R1 -> R1 STAR R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 52 (R1 -> R1 STAR R1 .)
    MINUS           reduce using rule 52 (R1 -> R1 STAR R1 .)
    DIVIDE          reduce using rule 52 (R1 -> R1 STAR R1 .)
    SEMICOLON       reduce using rule 52 (R1 -> R1 STAR R1 .)
    RPAREN          reduce using rule 52 (R1 -> R1 STAR R1 .)
    STAR            shift and go to state 143

  ! STAR            [ reduce using rule 52 (R1 -> R1 STAR R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]
  ! DIVIDE          [ shift and go to state 147 ]


state 175

    (44) R1 -> R1 STAR ALLNUM .
    (46) R1 -> ALLNUM . PLUS R1
    (47) R1 -> ALLNUM . MINUS R1
    (48) R1 -> ALLNUM . STAR R1
    (49) R1 -> ALLNUM . DIVIDE R1

    PLUS            reduce using rule 44 (R1 -> R1 STAR ALLNUM .)
    MINUS           reduce using rule 44 (R1 -> R1 STAR ALLNUM .)
    DIVIDE          reduce using rule 44 (R1 -> R1 STAR ALLNUM .)
    SEMICOLON       reduce using rule 44 (R1 -> R1 STAR ALLNUM .)
    RPAREN          reduce using rule 44 (R1 -> R1 STAR ALLNUM .)
    STAR            shift and go to state 148

  ! STAR            [ reduce using rule 44 (R1 -> R1 STAR ALLNUM .) ]
  ! PLUS            [ shift and go to state 151 ]
  ! MINUS           [ shift and go to state 149 ]
  ! DIVIDE          [ shift and go to state 150 ]


state 176

    (60) ALLNUM -> MINUS . ALLNUM
    (55) R1 -> MINUS . R1
    (59) ALLNUM -> . NUMBER
    (60) ALLNUM -> . MINUS ALLNUM
    (42) R1 -> . R1 PLUS ALLNUM
    (43) R1 -> . R1 MINUS ALLNUM
    (44) R1 -> . R1 STAR ALLNUM
    (45) R1 -> . R1 DIVIDE ALLNUM
    (46) R1 -> . ALLNUM PLUS R1
    (47) R1 -> . ALLNUM MINUS R1
    (48) R1 -> . ALLNUM STAR R1
    (49) R1 -> . ALLNUM DIVIDE R1
    (50) R1 -> . R1 PLUS R1
    (51) R1 -> . R1 MINUS R1
    (52) R1 -> . R1 STAR R1
    (53) R1 -> . R1 DIVIDE R1
    (54) R1 -> . LPAREN R1 RPAREN
    (55) R1 -> . MINUS R1
    (56) R1 -> . PName
    (57) R1 -> . function_call
    (58) R1 -> . NAME
    (73) PName -> . STAR PName
    (74) PName -> . STAR NAME
    (75) PName -> . AMPERSAND NAME
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN

    NUMBER          shift and go to state 118
    MINUS           shift and go to state 176
    LPAREN          shift and go to state 120
    NAME            shift and go to state 116
    STAR            shift and go to state 79
    AMPERSAND       shift and go to state 83

    ALLNUM                         shift and go to state 153
    PName                          shift and go to state 121
    R1                             shift and go to state 152
    function_call                  shift and go to state 115

state 177

    (51) R1 -> R1 MINUS R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 51 (R1 -> R1 MINUS R1 .)
    MINUS           reduce using rule 51 (R1 -> R1 MINUS R1 .)
    SEMICOLON       reduce using rule 51 (R1 -> R1 MINUS R1 .)
    RPAREN          reduce using rule 51 (R1 -> R1 MINUS R1 .)
    STAR            shift and go to state 143
    DIVIDE          shift and go to state 147

  ! STAR            [ reduce using rule 51 (R1 -> R1 MINUS R1 .) ]
  ! DIVIDE          [ reduce using rule 51 (R1 -> R1 MINUS R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]


state 178

    (43) R1 -> R1 MINUS ALLNUM .
    (46) R1 -> ALLNUM . PLUS R1
    (47) R1 -> ALLNUM . MINUS R1
    (48) R1 -> ALLNUM . STAR R1
    (49) R1 -> ALLNUM . DIVIDE R1

    PLUS            reduce using rule 43 (R1 -> R1 MINUS ALLNUM .)
    MINUS           reduce using rule 43 (R1 -> R1 MINUS ALLNUM .)
    SEMICOLON       reduce using rule 43 (R1 -> R1 MINUS ALLNUM .)
    RPAREN          reduce using rule 43 (R1 -> R1 MINUS ALLNUM .)
    STAR            shift and go to state 148
    DIVIDE          shift and go to state 150

  ! STAR            [ reduce using rule 43 (R1 -> R1 MINUS ALLNUM .) ]
  ! DIVIDE          [ reduce using rule 43 (R1 -> R1 MINUS ALLNUM .) ]
  ! PLUS            [ shift and go to state 151 ]
  ! MINUS           [ shift and go to state 149 ]


state 179

    (50) R1 -> R1 PLUS R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 50 (R1 -> R1 PLUS R1 .)
    MINUS           reduce using rule 50 (R1 -> R1 PLUS R1 .)
    SEMICOLON       reduce using rule 50 (R1 -> R1 PLUS R1 .)
    RPAREN          reduce using rule 50 (R1 -> R1 PLUS R1 .)
    STAR            shift and go to state 143
    DIVIDE          shift and go to state 147

  ! STAR            [ reduce using rule 50 (R1 -> R1 PLUS R1 .) ]
  ! DIVIDE          [ reduce using rule 50 (R1 -> R1 PLUS R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]


state 180

    (42) R1 -> R1 PLUS ALLNUM .
    (46) R1 -> ALLNUM . PLUS R1
    (47) R1 -> ALLNUM . MINUS R1
    (48) R1 -> ALLNUM . STAR R1
    (49) R1 -> ALLNUM . DIVIDE R1

    PLUS            reduce using rule 42 (R1 -> R1 PLUS ALLNUM .)
    MINUS           reduce using rule 42 (R1 -> R1 PLUS ALLNUM .)
    SEMICOLON       reduce using rule 42 (R1 -> R1 PLUS ALLNUM .)
    RPAREN          reduce using rule 42 (R1 -> R1 PLUS ALLNUM .)
    STAR            shift and go to state 148
    DIVIDE          shift and go to state 150

  ! STAR            [ reduce using rule 42 (R1 -> R1 PLUS ALLNUM .) ]
  ! DIVIDE          [ reduce using rule 42 (R1 -> R1 PLUS ALLNUM .) ]
  ! PLUS            [ shift and go to state 151 ]
  ! MINUS           [ shift and go to state 149 ]


state 181

    (53) R1 -> R1 DIVIDE R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 53 (R1 -> R1 DIVIDE R1 .)
    MINUS           reduce using rule 53 (R1 -> R1 DIVIDE R1 .)
    DIVIDE          reduce using rule 53 (R1 -> R1 DIVIDE R1 .)
    SEMICOLON       reduce using rule 53 (R1 -> R1 DIVIDE R1 .)
    RPAREN          reduce using rule 53 (R1 -> R1 DIVIDE R1 .)
    STAR            shift and go to state 143

  ! STAR            [ reduce using rule 53 (R1 -> R1 DIVIDE R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]
  ! DIVIDE          [ shift and go to state 147 ]


state 182

    (45) R1 -> R1 DIVIDE ALLNUM .
    (46) R1 -> ALLNUM . PLUS R1
    (47) R1 -> ALLNUM . MINUS R1
    (48) R1 -> ALLNUM . STAR R1
    (49) R1 -> ALLNUM . DIVIDE R1

    PLUS            reduce using rule 45 (R1 -> R1 DIVIDE ALLNUM .)
    MINUS           reduce using rule 45 (R1 -> R1 DIVIDE ALLNUM .)
    DIVIDE          reduce using rule 45 (R1 -> R1 DIVIDE ALLNUM .)
    SEMICOLON       reduce using rule 45 (R1 -> R1 DIVIDE ALLNUM .)
    RPAREN          reduce using rule 45 (R1 -> R1 DIVIDE ALLNUM .)
    STAR            shift and go to state 148

  ! STAR            [ reduce using rule 45 (R1 -> R1 DIVIDE ALLNUM .) ]
  ! PLUS            [ shift and go to state 151 ]
  ! MINUS           [ shift and go to state 149 ]
  ! DIVIDE          [ shift and go to state 150 ]


state 183

    (48) R1 -> ALLNUM STAR R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 48 (R1 -> ALLNUM STAR R1 .)
    MINUS           reduce using rule 48 (R1 -> ALLNUM STAR R1 .)
    DIVIDE          reduce using rule 48 (R1 -> ALLNUM STAR R1 .)
    SEMICOLON       reduce using rule 48 (R1 -> ALLNUM STAR R1 .)
    RPAREN          reduce using rule 48 (R1 -> ALLNUM STAR R1 .)
    STAR            shift and go to state 143

  ! STAR            [ reduce using rule 48 (R1 -> ALLNUM STAR R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]
  ! DIVIDE          [ shift and go to state 147 ]


state 184

    (47) R1 -> ALLNUM MINUS R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 47 (R1 -> ALLNUM MINUS R1 .)
    MINUS           reduce using rule 47 (R1 -> ALLNUM MINUS R1 .)
    SEMICOLON       reduce using rule 47 (R1 -> ALLNUM MINUS R1 .)
    RPAREN          reduce using rule 47 (R1 -> ALLNUM MINUS R1 .)
    STAR            shift and go to state 143
    DIVIDE          shift and go to state 147

  ! STAR            [ reduce using rule 47 (R1 -> ALLNUM MINUS R1 .) ]
  ! DIVIDE          [ reduce using rule 47 (R1 -> ALLNUM MINUS R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]


state 185

    (49) R1 -> ALLNUM DIVIDE R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 49 (R1 -> ALLNUM DIVIDE R1 .)
    MINUS           reduce using rule 49 (R1 -> ALLNUM DIVIDE R1 .)
    DIVIDE          reduce using rule 49 (R1 -> ALLNUM DIVIDE R1 .)
    SEMICOLON       reduce using rule 49 (R1 -> ALLNUM DIVIDE R1 .)
    RPAREN          reduce using rule 49 (R1 -> ALLNUM DIVIDE R1 .)
    STAR            shift and go to state 143

  ! STAR            [ reduce using rule 49 (R1 -> ALLNUM DIVIDE R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]
  ! DIVIDE          [ shift and go to state 147 ]


state 186

    (46) R1 -> ALLNUM PLUS R1 .
    (42) R1 -> R1 . PLUS ALLNUM
    (43) R1 -> R1 . MINUS ALLNUM
    (44) R1 -> R1 . STAR ALLNUM
    (45) R1 -> R1 . DIVIDE ALLNUM
    (50) R1 -> R1 . PLUS R1
    (51) R1 -> R1 . MINUS R1
    (52) R1 -> R1 . STAR R1
    (53) R1 -> R1 . DIVIDE R1

    PLUS            reduce using rule 46 (R1 -> ALLNUM PLUS R1 .)
    MINUS           reduce using rule 46 (R1 -> ALLNUM PLUS R1 .)
    SEMICOLON       reduce using rule 46 (R1 -> ALLNUM PLUS R1 .)
    RPAREN          reduce using rule 46 (R1 -> ALLNUM PLUS R1 .)
    STAR            shift and go to state 143
    DIVIDE          shift and go to state 147

  ! STAR            [ reduce using rule 46 (R1 -> ALLNUM PLUS R1 .) ]
  ! DIVIDE          [ reduce using rule 46 (R1 -> ALLNUM PLUS R1 .) ]
  ! PLUS            [ shift and go to state 146 ]
  ! MINUS           [ shift and go to state 145 ]


state 187

    (54) R1 -> LPAREN R1 RPAREN .

    PLUS            reduce using rule 54 (R1 -> LPAREN R1 RPAREN .)
    MINUS           reduce using rule 54 (R1 -> LPAREN R1 RPAREN .)
    STAR            reduce using rule 54 (R1 -> LPAREN R1 RPAREN .)
    DIVIDE          reduce using rule 54 (R1 -> LPAREN R1 RPAREN .)
    SEMICOLON       reduce using rule 54 (R1 -> LPAREN R1 RPAREN .)
    RPAREN          reduce using rule 54 (R1 -> LPAREN R1 RPAREN .)


state 188

    (101) matched_decision -> IF LPAREN condition RPAREN body ELSE . matched_stmt
    (102) matched_decision -> IF LPAREN condition RPAREN body ELSE . body
    (104) matched_decision -> IF LPAREN condition RPAREN body ELSE . SEMICOLON
    (112) unmatched_decision -> IF LPAREN condition RPAREN body ELSE . unmatched_stmt
    (32) matched_stmt -> . assign
    (33) matched_stmt -> . declaration
    (34) matched_stmt -> . matched_decision
    (35) matched_stmt -> . matched_loop
    (36) matched_stmt -> . function_call SEMICOLON
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY
    (37) unmatched_stmt -> . unmatched_decision
    (38) unmatched_stmt -> . unmatched_loop
    (39) assign -> . L1 EQUALS R1 SEMICOLON
    (40) assign -> . L2 EQUALS R2 SEMICOLON
    (80) declaration -> . TYPE varlist SEMICOLON
    (99) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> . IF LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> . IF LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> . IF LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (85) matched_loop -> . WHILE LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> . WHILE LPAREN condition RPAREN body
    (87) matched_loop -> . WHILE LPAREN condition RPAREN SEMICOLON
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN
    (108) unmatched_decision -> . IF LPAREN condition RPAREN stmt
    (109) unmatched_decision -> . IF LPAREN condition RPAREN body
    (110) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> . IF LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt
    (88) unmatched_loop -> . WHILE LPAREN condition RPAREN unmatched_stmt
    (41) L1 -> . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    SEMICOLON       shift and go to state 194
    LCURLY          shift and go to state 157
    IF              shift and go to state 55
    WHILE           shift and go to state 66
    NAME            shift and go to state 59
    STAR            shift and go to state 52
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    unmatched_decision             shift and go to state 51
    L2                             shift and go to state 49
    TYPE                           shift and go to state 56
    function_call                  shift and go to state 58
    declaration                    shift and go to state 50
    matched_loop                   shift and go to state 62
    assign                         shift and go to state 54
    body                           shift and go to state 192
    matched_decision               shift and go to state 53
    unmatched_loop                 shift and go to state 63
    matched_stmt                   shift and go to state 193
    unmatched_stmt                 shift and go to state 195
    L1                             shift and go to state 68

state 189

    (26) body -> LCURLY stmt_list . RCURLY

    RCURLY          shift and go to state 89


state 190

    (99) matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE . matched_stmt
    (100) matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE . body
    (103) matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE . SEMICOLON
    (111) unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE . unmatched_stmt
    (32) matched_stmt -> . assign
    (33) matched_stmt -> . declaration
    (34) matched_stmt -> . matched_decision
    (35) matched_stmt -> . matched_loop
    (36) matched_stmt -> . function_call SEMICOLON
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY
    (37) unmatched_stmt -> . unmatched_decision
    (38) unmatched_stmt -> . unmatched_loop
    (39) assign -> . L1 EQUALS R1 SEMICOLON
    (40) assign -> . L2 EQUALS R2 SEMICOLON
    (80) declaration -> . TYPE varlist SEMICOLON
    (99) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> . IF LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> . IF LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> . IF LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (85) matched_loop -> . WHILE LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> . WHILE LPAREN condition RPAREN body
    (87) matched_loop -> . WHILE LPAREN condition RPAREN SEMICOLON
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN
    (108) unmatched_decision -> . IF LPAREN condition RPAREN stmt
    (109) unmatched_decision -> . IF LPAREN condition RPAREN body
    (110) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> . IF LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt
    (88) unmatched_loop -> . WHILE LPAREN condition RPAREN unmatched_stmt
    (41) L1 -> . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    SEMICOLON       shift and go to state 198
    LCURLY          shift and go to state 157
    IF              shift and go to state 55
    WHILE           shift and go to state 66
    NAME            shift and go to state 59
    STAR            shift and go to state 52
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    unmatched_decision             shift and go to state 51
    L2                             shift and go to state 49
    TYPE                           shift and go to state 56
    function_call                  shift and go to state 58
    declaration                    shift and go to state 50
    matched_loop                   shift and go to state 62
    assign                         shift and go to state 54
    body                           shift and go to state 196
    matched_decision               shift and go to state 53
    unmatched_loop                 shift and go to state 63
    matched_stmt                   shift and go to state 197
    unmatched_stmt                 shift and go to state 199
    L1                             shift and go to state 68

state 191

    (105) matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE . matched_stmt
    (106) matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE . body
    (107) matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE . SEMICOLON
    (113) unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE . unmatched_stmt
    (32) matched_stmt -> . assign
    (33) matched_stmt -> . declaration
    (34) matched_stmt -> . matched_decision
    (35) matched_stmt -> . matched_loop
    (36) matched_stmt -> . function_call SEMICOLON
    (26) body -> . LCURLY stmt_list RCURLY
    (27) body -> . LCURLY RCURLY
    (37) unmatched_stmt -> . unmatched_decision
    (38) unmatched_stmt -> . unmatched_loop
    (39) assign -> . L1 EQUALS R1 SEMICOLON
    (40) assign -> . L2 EQUALS R2 SEMICOLON
    (80) declaration -> . TYPE varlist SEMICOLON
    (99) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt
    (100) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE body
    (101) matched_decision -> . IF LPAREN condition RPAREN body ELSE matched_stmt
    (102) matched_decision -> . IF LPAREN condition RPAREN body ELSE body
    (103) matched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON
    (104) matched_decision -> . IF LPAREN condition RPAREN body ELSE SEMICOLON
    (105) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt
    (106) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE body
    (107) matched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON
    (85) matched_loop -> . WHILE LPAREN condition RPAREN matched_stmt
    (86) matched_loop -> . WHILE LPAREN condition RPAREN body
    (87) matched_loop -> . WHILE LPAREN condition RPAREN SEMICOLON
    (76) function_call -> . NAME LPAREN arg_list RPAREN
    (77) function_call -> . NAME LPAREN RPAREN
    (108) unmatched_decision -> . IF LPAREN condition RPAREN stmt
    (109) unmatched_decision -> . IF LPAREN condition RPAREN body
    (110) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON
    (111) unmatched_decision -> . IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt
    (112) unmatched_decision -> . IF LPAREN condition RPAREN body ELSE unmatched_stmt
    (113) unmatched_decision -> . IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt
    (88) unmatched_loop -> . WHILE LPAREN condition RPAREN unmatched_stmt
    (41) L1 -> . NAME
    (61) L2 -> . STAR L2
    (62) L2 -> . STAR NAME
    (19) TYPE -> . INT
    (20) TYPE -> . FLOAT

    SEMICOLON       shift and go to state 202
    LCURLY          shift and go to state 157
    IF              shift and go to state 55
    WHILE           shift and go to state 66
    NAME            shift and go to state 59
    STAR            shift and go to state 52
    INT             shift and go to state 5
    FLOAT           shift and go to state 2

    unmatched_decision             shift and go to state 51
    L2                             shift and go to state 49
    TYPE                           shift and go to state 56
    function_call                  shift and go to state 58
    declaration                    shift and go to state 50
    matched_loop                   shift and go to state 62
    assign                         shift and go to state 54
    body                           shift and go to state 200
    matched_decision               shift and go to state 53
    unmatched_loop                 shift and go to state 63
    matched_stmt                   shift and go to state 201
    unmatched_stmt                 shift and go to state 203
    L1                             shift and go to state 68

state 192

    (102) matched_decision -> IF LPAREN condition RPAREN body ELSE body .

    IF              reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)
    WHILE           reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)
    NAME            reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)
    STAR            reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)
    INT             reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)
    FLOAT           reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)
    RCURLY          reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)
    RETURN          reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)
    ELSE            reduce using rule 102 (matched_decision -> IF LPAREN condition RPAREN body ELSE body .)


state 193

    (101) matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .

    IF              reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)
    WHILE           reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)
    NAME            reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)
    STAR            reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)
    INT             reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)
    FLOAT           reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)
    RCURLY          reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)
    RETURN          reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)
    ELSE            reduce using rule 101 (matched_decision -> IF LPAREN condition RPAREN body ELSE matched_stmt .)


state 194

    (104) matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .

    IF              reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)
    WHILE           reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)
    NAME            reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)
    STAR            reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)
    INT             reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)
    FLOAT           reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)
    RCURLY          reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)
    RETURN          reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)
    ELSE            reduce using rule 104 (matched_decision -> IF LPAREN condition RPAREN body ELSE SEMICOLON .)


state 195

    (112) unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .

    IF              reduce using rule 112 (unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .)
    WHILE           reduce using rule 112 (unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .)
    NAME            reduce using rule 112 (unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .)
    STAR            reduce using rule 112 (unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .)
    INT             reduce using rule 112 (unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .)
    FLOAT           reduce using rule 112 (unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .)
    RCURLY          reduce using rule 112 (unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .)
    RETURN          reduce using rule 112 (unmatched_decision -> IF LPAREN condition RPAREN body ELSE unmatched_stmt .)


state 196

    (100) matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .

    IF              reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)
    WHILE           reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)
    NAME            reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)
    STAR            reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)
    INT             reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)
    FLOAT           reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)
    RCURLY          reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)
    RETURN          reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)
    ELSE            reduce using rule 100 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE body .)


state 197

    (99) matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .

    IF              reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)
    WHILE           reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)
    NAME            reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)
    STAR            reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)
    INT             reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)
    FLOAT           reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)
    RCURLY          reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)
    RETURN          reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)
    ELSE            reduce using rule 99 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE matched_stmt .)


state 198

    (103) matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .

    IF              reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)
    WHILE           reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)
    NAME            reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)
    STAR            reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)
    INT             reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)
    FLOAT           reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)
    RCURLY          reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)
    RETURN          reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)
    ELSE            reduce using rule 103 (matched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE SEMICOLON .)


state 199

    (111) unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .

    IF              reduce using rule 111 (unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .)
    WHILE           reduce using rule 111 (unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .)
    NAME            reduce using rule 111 (unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .)
    STAR            reduce using rule 111 (unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .)
    INT             reduce using rule 111 (unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .)
    FLOAT           reduce using rule 111 (unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .)
    RCURLY          reduce using rule 111 (unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .)
    RETURN          reduce using rule 111 (unmatched_decision -> IF LPAREN condition RPAREN matched_stmt ELSE unmatched_stmt .)


state 200

    (106) matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .

    IF              reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)
    WHILE           reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)
    NAME            reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)
    STAR            reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)
    INT             reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)
    FLOAT           reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)
    RCURLY          reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)
    RETURN          reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)
    ELSE            reduce using rule 106 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE body .)


state 201

    (105) matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .

    IF              reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)
    WHILE           reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)
    NAME            reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)
    STAR            reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)
    INT             reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)
    FLOAT           reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)
    RCURLY          reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)
    RETURN          reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)
    ELSE            reduce using rule 105 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE matched_stmt .)


state 202

    (107) matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .

    IF              reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)
    WHILE           reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)
    NAME            reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)
    STAR            reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)
    INT             reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)
    FLOAT           reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)
    RCURLY          reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)
    RETURN          reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)
    ELSE            reduce using rule 107 (matched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE SEMICOLON .)


state 203

    (113) unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .

    IF              reduce using rule 113 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .)
    WHILE           reduce using rule 113 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .)
    NAME            reduce using rule 113 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .)
    STAR            reduce using rule 113 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .)
    INT             reduce using rule 113 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .)
    FLOAT           reduce using rule 113 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .)
    RCURLY          reduce using rule 113 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .)
    RETURN          reduce using rule 113 (unmatched_decision -> IF LPAREN condition RPAREN SEMICOLON ELSE unmatched_stmt .)

